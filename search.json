[{"title":"广西旅游","path":"/2024/06/24/旅游/广西/","content":"桂林7.10 北海-桂林站 高铁 酒店选择市区靠近桂林北的 7.11 桂林北-阳朔 24min 桂林千古情 16.00 1h 阳朔-桂林北 query.prepare( “SELECT” “CASE” “WHEN User_id1 &#x3D; :user_id1 THEN User_id2” “ELSE User_id1” “END AS Related_User_id” “FROM Friend” “WHERE User_id1 &#x3D; :user_id1 OR User_id2 &#x3D; :user_id1;” ); query.prepare(“INSERT INTO Friend (User_id1, User_id2,status) VALUES (:user_id1, :user_id2,’accepted’)”);","tags":["桂林","北海","阳朔"],"categories":["旅游"]},{"title":"力扣面试50题","path":"/2024/06/09/leetcode/","content":"数组&#x2F;字符串88 合并两个有序数组非递减顺序：从小到大排列 1234输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] 我的：先nums2中插入到nums1中0的位置 然后使用选择排序 123456789101112131415161718class Solution &#123; //排序public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; for(int i=m;i&lt;m+n;i++)&#123; nums1[i]=nums2[i-m]; &#125; int i,j; for(i=1; i&lt;n+m; i++) &#123; //sort(nums1.begin(), nums1.end()); if(nums1[i]&lt;nums1[i-1]) &#123; int temp=nums1[i]; for(j=i-1; j&gt;=0 &amp;&amp; nums1[j]&gt;temp; j--) &#123; nums1[j+1]=nums1[j]; &#125; nums1[j+1]=temp; &#125; &#125; &#125;&#125;; 双指针 利用两个数组已经有序，创建一个新的数组，每次取两个数组中的最小放进去 1234567891011121314151617181920212223class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int p1 = 0, p2 = 0; int sorted[m + n]; int cur; while (p1 &lt; m || p2 &lt; n) &#123; if (p1 == m) &#123; cur = nums2[p2++]; &#125; else if (p2 == n) &#123; cur = nums1[p1++]; &#125; else if (nums1[p1] &lt; nums2[p2]) &#123; cur = nums1[p1++]; &#125; else &#123; cur = nums2[p2++]; &#125; sorted[p1 + p2 - 1] = cur; &#125; for (int i = 0; i != m + n; ++i) &#123; nums1[i] = sorted[i]; &#125; &#125;&#125;; 逆向双指针 0ms 避免使用临时变量创建一个新的数组，不用担心覆盖nums1的问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//我的class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int l=m-1; int j=n-1; int i=m+n-1; while(j&gt;=0)&#123; if(l&gt;=0&amp;&amp;nums1[l]&gt;nums2[j])&#123; nums1[i]=nums1[l]; l--; &#125;else&#123; nums1[i]=nums2[j]; j--; &#125; i--; &#125; &#125;&#125;; class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int p1 = m - 1, p2 = n - 1; int tail = m + n - 1; int cur; while (p1 &gt;= 0 || p2 &gt;= 0) &#123; if (p1 == -1) &#123; cur = nums2[p2--]; &#125; else if (p2 == -1) &#123; cur = nums1[p1--]; &#125; else if (nums1[p1] &gt; nums2[p2]) &#123; cur = nums1[p1--]; &#125; else &#123; cur = nums2[p2--]; &#125; nums1[tail--] = cur; &#125; &#125;&#125;;class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int left = m - 1, right = n - 1, cur = m + n - 1; while (left &gt;= 0 &amp;&amp; right &gt;= 0) nums1[cur--] = nums1[left] &gt; nums2[right] ? nums1[left--] : nums2[right--]; //&gt;优先级大于= // nums1剩下的已经排序，可以跳过 while (right &gt;= 0) nums1[cur--] = nums2[right--]; &#125;&#125;; 27 移除元素返回剩下的元素个数 12输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3] 0ms 12345678910111213class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; vector&lt;int&gt;::iterator it=nums.begin(); for(;it&lt;nums.end();it++)&#123; if(*it==val)&#123; nums.erase(it); it--; &#125; &#125; return nums.size(); &#125;&#125;; 或 使用双指针 26 删除有序数组中的重复项给你一个 升序排列 的数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。 12345678910111213141516//484ms 迭代器class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt;::iterator it=nums.begin(); for(;it&lt;nums.end()-1;it++)&#123; for(vector&lt;int&gt;::iterator j=(it+1);j&lt;nums.end();j++)&#123; if(*j==*it)&#123; nums.erase(j); j--; &#125; &#125; &#125; return nums.size(); &#125;&#125;; 因为是有序的，所以只需要从头到尾连续的两个进行比较，至少剩一个 1234567891011121314//540msclass Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt;::iterator it=nums.begin(); for(;it&lt;nums.end()-1;it++)&#123; vector&lt;int&gt;::iterator j=(it+1); if(*j==*it)&#123; nums.erase(j);it--; &#125; &#125; return nums.size(); &#125;&#125;; it–&#x3D;&#x3D;???&#x3D;&#x3D; 双指针 将有序的排在前面， p前q后 q外层遍历 q找到和q不一样的复制到p的下一位 12345678910111213141516171819//12msclass Solution&#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; int p = 0; int q = 1; while(q &lt; nums.size())&#123; if(nums[p] != nums[q])&#123; if(q - p &gt; 1)&#123; nums[p + 1] = nums[q]; &#125; p++; &#125; q++; &#125; return p + 1; &#125;&#125;; 80 删除有序数组中的重复项Ⅱ1234567891011121314151617//8msclass Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt;::iterator it=nums.begin(); vector&lt;int&gt;::iterator j; while(it&lt;nums.end()-2)&#123; j=it+1; if(*j==*it&amp;&amp;*(j+1)==*it)&#123; nums.erase(j); &#125;else&#123; it++; //不相等才it++ 防止大于三个相同的漏掉 &#125; &#125; return nums.size(); &#125;&#125;; 双指针 slow表示处理出的数组长度 fast表示已经检查过的长度 12345678910111213141516171819//0msclass Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt;= 2) &#123; return n; &#125; int slow = 2, fast = 2; //从2开始，前面2个都是不用动的 while (fast &lt; n) &#123; if (nums[slow - 2] != nums[fast]) &#123; //不相等可以保存 nums[slow] = nums[fast]; //保存 ++slow; //保存数目+1 &#125; ++fast; //检查数目+1 &#125; return slow; &#125;&#125;; 删除重复项的通解&#x3D;&#x3D;？？？&#x3D;&#x3D; 1234567891011121314//4msclass Solution &#123;public: int work(vector&lt;int&gt;&amp; nums, int k) &#123; int len = 0; for(auto num : nums) if(len &lt; k || nums[len-k] != num) nums[len++] = num; return len; &#125; int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; return work(nums, 2); &#125;&#125;; 169 多数元素给定大小为n的数组，返回多数元素（个数大于n&#x2F;2） 利用两个循环 时间复杂度O² 会超时 1234567891011121314151617class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int max=0; for(int i=0;i&lt;nums.size();i++)&#123; for(int j=i;j&lt;nums.size();j++)&#123; if(nums[j]==nums[i]) max++; if(max&gt;nums.size()/2)&#123; return nums[i]; &#125; &#125; max=0; &#125; return 0; &#125;&#125;; 哈希表 我们使用哈希映射（HashMap）来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。我们同样也可以在遍历数组 nums 时候使用打擂台的方法，维护最大的值，这样省去了最后对哈希映射的遍历。&#x3D;&#x3D;？？？&#x3D;&#x3D; 12345678910111213141516//24ms n n\tclass Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; counts; //创建哈希表统计元素出现的次数 int majority = 0, cnt = 0; //当前的众数 和次数 for (int num: nums) &#123; ++counts[num]; //增加counts中nun对于的值 if (counts[num] &gt; cnt) &#123; //nun对于的值出现的次数&gt;当前众数 更新 majority = num; cnt = counts[num]; &#125; &#125; return majority; &#125;&#125;; 排序 从小到大排序 下标n&#x2F;2处一定为次数多的 12345678//20ms nlogn logn 自己编写堆排序O1class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); return nums[nums.size() / 2]; &#125;&#125;; 随机化 12345678910111213141516//8ms 期望n 1class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; while (true) &#123; int candidate = nums[rand() % nums.size()]; int count = 0; for (int num : nums) if (num == candidate) ++count; if (count &gt; nums.size() / 2) return candidate; &#125; return -1; &#125;&#125;; 分治 思路 如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。 我们可以使用反证法来证明这个结论。假设 a 既不是左半部分的众数，也不是右半部分的众数，那么 a 出现的次数少于 l &#x2F; 2 + r &#x2F; 2 次，其中 l 和 r 分别是左半部分和右半部分的长度。由于 l &#x2F; 2 + r &#x2F; 2 &lt;&#x3D; (l + r) &#x2F; 2，说明 a 也不是数组 nums 的众数，因此出现了矛盾。所以这个结论是正确的。 这样以来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。 算法 我们使用经典的分治算法递归求解，直到所有的子问题都是长度为 1 的数组。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。 1234567891011121314151617181920212223242526// 40ms nlogn lognclass Solution &#123; int count_in_range(vector&lt;int&gt;&amp; nums, int target, int lo, int hi) &#123; int count = 0; for (int i = lo; i &lt;= hi; ++i) if (nums[i] == target) ++count; return count; &#125; int majority_element_rec(vector&lt;int&gt;&amp; nums, int lo, int hi) &#123; if (lo == hi) return nums[lo]; int mid = (lo + hi) / 2; int left_majority = majority_element_rec(nums, lo, mid); int right_majority = majority_element_rec(nums, mid + 1, hi); if (count_in_range(nums, left_majority, lo, hi) &gt; (hi - lo + 1) / 2) return left_majority; if (count_in_range(nums, right_majority, lo, hi) &gt; (hi - lo + 1) / 2) return right_majority; return -1; &#125;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; return majority_element_rec(nums, 0, nums.size() - 1); &#125;&#125;; boyer-moore 投票算法 我们维护一个候选众数 candidate 和它出现的次数 count。count 为 0； 我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x： 如果 x 与 candidate 相等，那么计数器 count 的值增加 1；如果 x 与 candidate 不等，那么计数器 count 的值减少 1。 在遍历完成后，candidate 即为整个数组的众数。 123456789101112//16 n 1class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int x = 0, votes = 0; for (int num : nums)&#123; if (votes == 0) x = num; votes += num == x ? 1 : -1; //如果num=x +1 else -1 &#125; return x; &#125;&#125;; 189 轮转数组给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 使用另一个数组辅助 12345678910111213//28msclass Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int a=nums.size(); vector&lt;int&gt; nums2(a); for(int i=0;i&lt;a;i++)&#123; int j=(i+k)%a; nums2[j]=nums[i]; &#125; nums=nums2; &#125;&#125;; 环状替换 一个临时变量x x保存0+k位 0+k位&#x3D;0位 0位&#x3D;x x保存(0+2k)%n位 (0+2k)%n位&#x3D;0位 一直循环，回到0位，但不能保证全部都轮了，要有一个计数器计数没有完下一轮从1位开始 &#x3D;&#x3D;？？？&#x3D;&#x3D; 123456789101112131415161718//40msclass Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); k = k % n; int count = gcd(k, n); //最大公约数 for (int start = 0; start &lt; count; ++start) &#123; int current = start; int prev = nums[start]; do &#123; int next = (current + k) % n; swap(nums[next], prev); current = next; &#125; while (start != current); &#125; &#125;&#125;; 数组翻转 我们可以先将所有元素翻转，这样尾部的 k%n个元素就被移至数组头部，然后我们再翻转 [0,k%n−1] 区间的元素和 [k%n,n−1] 区间的元素即能得到最后的答案。 123456789101112131415161718//28msclass Solution &#123;public: void reverse(vector&lt;int&gt;&amp; nums, int start, int end) &#123; while (start &lt; end) &#123; swap(nums[start], nums[end]); start += 1; end -= 1; &#125; &#125; void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; k %= nums.size(); reverse(nums, 0, nums.size() - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.size() - 1); &#125;&#125;; 121 买卖股票的最佳时机给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 要在一条线上找跨度最大的，直接用后面数字-前面的看谁最大n^2 直接超时 123456789101112131415161718class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int temp=0; int n=prices.size(); for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(prices[i]-prices[j]&lt;temp) temp=prices[i]-prices[j]; &#125; &#125; if(temp&lt;0)&#123; return -1*temp; &#125;else&#123; return 0; &#125; &#125;&#125;; n 动态规划 123456789101112131415161718192021//96msclass Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); if (n &lt;= 1) return 0; int maxProfit = 0; int minPrice = prices[0]; for (int i = 1; i &lt; n; i++) &#123; if (prices[i] &lt; minPrice) minPrice = prices[i]; else if (prices[i] - minPrice &gt; maxProfit) maxProfit = prices[i] - minPrice; &#125; return maxProfit; &#125;&#125;; for(i:)中i是一个什么对象？ ###122 买股票的最佳时机Ⅱ 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 示例 1： 12345输入：prices = [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 相当于就是求所有能的利润 1234567891011121314151617180msclass Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int sum=0; int n=prices.size(); int a=prices[0]; for(int i=1;i&lt;n;i++)&#123; if(prices[i]&gt;a)&#123; sum+=prices[i]-a; a=prices[i]; &#125;else&#123; a=prices[i]; &#125; &#125; return sum; &#125;&#125;; ###55 跳跃游戏 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。 示例 1： 123输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2： 123输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 123456789101112//60msclass Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int k = 0; //到达的最大下标 for (int i = 0; i &lt; nums.size(); i++) &#123; if (i &gt; k) return false; //到不到这个i k = max(k, i + nums[i]);//i + nums[i]在下标i基础上跳多少 &#125; return true; &#125;&#125;; ###45 跳跃游戏Ⅱ 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。 下标0的位置，如果能跳到下标1，2，这是我们并不清楚我们应该跳到哪一个，而应该进行一次选择，如果下标1能跳3格，也就是能到达1+3&#x3D;4的位置，下标2只能跳一格，只能到达2+1&#x3D;3的位置，这是我们就应该选择首先跳到下标1，并且记录步数的变量+1 代码表示 12345678int j = start + nums[start];for (int i = start + 1; i &lt;= j &amp;&amp; i &lt;= end; i++) &#123;\tif ((nums[i] + i) &gt; Dmax) &#123; Dmax = nums[i] + i; //最远距离 start = i; //起跳点更新\t&#125;&#125; count++; 算法写好了，那么我们的程序应该是：把算法放进while循环中，结束条件是其距离能到达最后一位 12345678910111213141516171819//12msint jump(vector&lt;int&gt;&amp; nums) &#123; int end = nums.size() - 1; if (end == 0) return 0; int count = 0; int Dmax = nums[0]; int start = 0; while (Dmax &lt; end) &#123; int j = start + nums[start]; for (int i = start + 1; i &lt;= j &amp;&amp; i &lt;= end; i++) &#123; if ((nums[i] + i) &gt; Dmax) &#123; Dmax = nums[i] + i; start = i; &#125; &#125; count++; &#125; return count+1;&#125; ###274 H 指数 给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。 根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且每篇论文 至少 被引用 h 次。如果 h 有多种可能的值，**h 指数** 是其中最大的那个。 示例 1： 1234输入：citations = [3,0,6,1,5]输出：3 解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。 由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。 示例 2： 12输入：citations = [1,3,1]输出：1 从大到小遍历，H指数从大到小判断，内层遍历如果不满足指数的数目过多则H–重新判断 1234567891011121314151617//32msclass Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; for(int i=citations.size()-1;i&gt;=0;i--)&#123; int count=citations.size(); for(int j=0;j&lt;citations.size();j++)&#123; if(citations[j]&lt;i+1) count--; if(count&lt;=i) break; &#125; if(count&gt;=i+1)&#123; return i+1; &#125; &#125; return 0; &#125;&#125;; 官方：先排序 h和i向中间靠拢，一次循环意味着一篇文章h++次，最后至少h篇h次 123456789101112class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; sort(citations.begin(), citations.end()); int h = 0, i = citations.size() - 1; while (i &gt;= 0 &amp;&amp; citations[i] &gt; h) &#123; h++; i--; &#125; return h; &#125;&#125;; 二分&#x3D;&#x3D;？？？&#x3D;&#x3D; 首先，定义左右两个指针，分别指向数组的首尾，然后取中间值，并计算大于或等于中间值的元素个数。如果这个数大于或等于中间值，那么将左指针移动到中间值，反之，将右指针移动到中间值减1。这样，每次循环后，搜索区间就会减半，最终会找到H指数。 12345678910111213141516171819202122232425class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; int left=0,right=citations.size(); int mid=0,cnt=0; while(left&lt;right)&#123; // +1 防止死循环 mid=(left+right+1)&gt;&gt;1; cnt=0; for(int i=0;i&lt;citations.size();i++)&#123; if(citations[i]&gt;=mid)&#123; cnt++; &#125; &#125; if(cnt&gt;=mid)&#123; // 要找的答案在 [mid,right] 区间内 left=mid; &#125;else&#123; // 要找的答案在 [0,mid) 区间内 right=mid-1; &#125; &#125; return left; &#125;&#125;; ###238 除自身以外数组的乘积 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。 题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。 请 不要使用除法，且在 O(*n*) 时间复杂度内完成此题。 12345678910111213141516171819202122//超时class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; //二分 int left,right; vector&lt;int&gt; nums2(nums.size(),1);//全部赋为1，不用new空间 for(int mid=0;mid&lt;nums.size();mid++)&#123; left=0;right=nums.size()-1; while(left&lt;mid)&#123; nums2[mid]*=nums[left]; left++; &#125; while(right&gt;mid)&#123; nums2[mid]*=nums[right]; right--; &#125; &#125; return nums2;//要申请空间才能返回数组 &#125;&#125;;//改进:可以额外开辟一个数组,先记录左边每一位累乘的,再记录右边每一位累乘的s,这样就不会超时了 上三角下三角法 B[i]&#x3D;对应行乘积 返回B数组 先算下三角 ex:B[2]&#x3D;B[1]*A[1] for (int i &#x3D; 1; i &lt; len; i++) { ans[i] &#x3D; ans[i - 1] * nums[i - 1];} 再算上三角 ex: ans *&#x3D;(temp*nums) 12345678910111213141516171819//20msclass Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if (len == 0) return &#123;&#125;; vector&lt;int&gt; ans(len, 1); ans[0] = 1; int tmp = 1; for (int i = 1; i &lt; len; i++) &#123; ans[i] = ans[i - 1] * nums[i - 1]; &#125; for (int i = len - 2; i &gt;= 0; i--) &#123; tmp *= nums[i + 1]; ans[i] *= tmp; &#125; return ans; &#125;&#125;; 134 加油站在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 示例 1: 12345678910输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 123456789101112131415161718192021222324252627//112msclass Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int n=gas.size(); int m=cost.size(); vector&lt;int&gt;temp(n); auto it=temp.begin(); int min =0; int sum=0,index,l=0; for(int i=0,j=0;i&lt;n&amp;&amp;j&lt;m;i++,j++)&#123; (*it)=gas[i]-cost[j]; sum+=(*it); if(sum&lt;min)&#123; //min记录最小油量时刻（负油最多），它之后就是出发点 min=sum; index=i+1; &#125; ++it; &#125; if(sum&lt;0)&#123; return -1; &#125; if(min&gt;=0) return 0; //&gt;0是多解情况，从0开始走都可以 return index%n; &#125;&#125;; 12345678910111213141516171819202122//简化，但是耗时更多？class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int n=gas.size(); int min =0; int sum=0,index; for(int i=0;i&lt;n;i++)&#123; sum+=gas[i]-cost[i]; if(sum&lt;min)&#123; // min=sum; index=i+1; &#125; &#125; if(sum&lt;0)&#123; return -1; &#125; if(min&gt;=0) return 0; return index%n; &#125;&#125;; 135 分发糖果n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。 你需要按照以下要求，给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻两个孩子评分更高的孩子会获得更多的糖果。 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。 示例 1： 123输入：ratings = [1,2,2]输出：4解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//840ms 每次两个遍历int candy(vector&lt;int&gt;&amp; ratings) &#123; int all = 0; auto it = ratings.begin(); int temp1 = 0,temp2=0; for (; it != ratings.end(); ++it) &#123; int b = 0,c=0; if (it + 1 != ratings.end() &amp;&amp; *(it) &gt; *(it + 1)) &#123;//注意，此时我们不知道后一位是否比后两位大 int count = 2; auto j = it+1; while (j+1!=ratings.end()&amp;&amp; (*j) &gt; *(j + 1)) &#123; j++; count++; &#125; temp1 = count; b = 1; &#125; if (it != ratings.begin() &amp;&amp; *(it) &gt; *(it - 1)) &#123; int count = 2; auto j = it-1; while (j != ratings.begin() &amp;&amp; (*j) &gt; *(j - 1)) &#123; j--; count++; &#125; temp2 = count; c = 1; &#125; if (b == 0&amp;&amp;c==0) &#123; all += 1; &#125; else if (b == 1&amp;&amp;c==1) &#123; if (temp1 &gt;= temp2) &#123; all += temp1; &#125; else &#123; all += temp2; &#125; &#125; else if(b==0)&#123; all += temp2; &#125; else &#123; all += temp1; &#125; &#125; return all;&#125; 1234567891011121314151617181920212223242526//优化版本16msclass Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int n = ratings.size(); vector&lt;int&gt; candies(n, 1); // 初始化每个孩子至少有一个糖果 // 从左到右遍历，保证右边评分更高的孩子获得更多糖果 for (int i = 1; i &lt; n; ++i) &#123; if (ratings[i] &gt; ratings[i - 1]) &#123; candies[i] = candies[i - 1] + 1; &#125; &#125; // 从右到左遍历，保证左边评分更高的孩子获得更多糖果，同时考虑两边都评分更高的情况 for (int i = n - 2; i &gt;= 0; --i) &#123; if (ratings[i] &gt; ratings[i + 1]) &#123; candies[i] = max(candies[i], candies[i + 1] + 1); &#125; &#125; // 计算总糖果数量 int total = 0; for (int i = 0; i &lt; n; ++i) &#123; total += candies[i]; &#125; return total; &#125; &#125;; 12345678910111213141516171819202122232425//12ms ,不好想class Solution &#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int n = ratings.size(); int ret = 1; int inc = 1, dec = 0, pre = 1; for (int i = 1; i &lt; n; i++) &#123; if (ratings[i] &gt;= ratings[i - 1]) &#123; dec = 0;//出现大于，-序列归0 pre = ratings[i] == ratings[i - 1] ? 1 : pre + 1;//相等=1，前一个+1 ret += pre;//总糖 inc = pre;//递增序列 &#125; else &#123; dec++;//递减序列 if (dec == inc) &#123;//增序列=减序列时是特殊点 dec++; &#125; ret += dec; pre = 1; &#125; &#125; return ret; &#125;&#125;; 双指针核心思想：创建两个指针，一个指向头，一个指尾，根据条件遍历 15 三数之和给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请 你返回所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 1： 12345678输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。 难点：去除重复 -1 0 1 和 0 1 -1 属于重复的 所以先排序再去除重复遍历 1234567891011121314151617181920212223242526272829303132333435363738//108msclass Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ans; if(nums.size()&lt;3) return ans; sort(nums.begin(), nums.end()); if(nums[0]&gt;0) return ans; int i = 0; while(i&lt;nums.size())&#123; int left = i+1, right = nums.size()-1; while(left&lt; right)&#123; int y = nums[i]; int x = nums[left]; int z = nums[right]; if(x + y &gt;0-z)//z偏大 right--; else if(x + y &lt;0-z) left++; else&#123; ans.push_back(&#123;nums[i], nums[left], nums[right]&#125;); // 相同的left和right不应该再次出现，因此跳过 while(left&lt;right&amp;&amp;nums[left]==nums[left+1]) left++; while(left&lt;right&amp;&amp;nums[right] == nums[right-1]) right--; left++; right--; &#125; &#125; // 避免nums[i]作为第一个数重复出现 while(i+1&lt;nums.size()&amp;&amp;nums[i] == nums[i+1]) i++; i++; &#125; return ans; &#125;&#125;; ##滑动窗口 双指针的基础上，像一个窗口一样滑动遍历 209 长度最小的子数组给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例 1： 123输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。 从子数组长度遍历，从1开始，子数组长度越长时间越长 还有一种：遍历每一个元素，每个元素在其基础上从1开始 1234567891011121314151617181920212223//超时int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int count = 1; while (count &lt;= n) &#123; for (int i = 0; i &lt; n; i++) &#123; int temp = 0; int j = i; while (j&lt;n) &#123; if (j - i &lt;= count - 1) &#123; temp += nums[j]; &#125; else &#123; break; &#125; j++; &#125; if (temp &gt;= target) return count; &#125; count++; &#125; return 0;&#125; 滑动窗口法：定义两个指针，和一个临时变量用来保存最小的子数组长度 开始l和r两个指针指向开头，区间内和小于指定值则r右移，区间和大于指定值则保存长度且l左移，寻找后面是否有更短的数组 12345678910111213141516171819202122class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n == 0) &#123; return 0; &#125; int ans = INT_MAX; int start = 0, end = 0; int sum = 0; while (end &lt; n) &#123; sum += nums[end]; while (sum &gt;= s) &#123; ans = min(ans, end - start + 1); sum -= nums[start]; start++; &#125; end++; &#125; return ans == INT_MAX ? 0 : ans; &#125;&#125;; 123456789101112131415161718192021222324//12msclass Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int minLen = numeric_limits&lt;int&gt;::max();//更快！！！很多 int curSum = 0; int start = 0; for (int end = 0; end &lt; nums.size(); end++) &#123; //add current number curSum += nums[end]; // check if the current sum &gt;= s while (curSum &gt;= s) &#123; minLen = min(minLen, end - start + 1); curSum = curSum - nums[start]; start = start + 1; &#125; &#125; return minLen == numeric_limits&lt;int&gt;::max() ? 0 : minLen; &#125;&#125;; 矩阵###36 有效的数独 请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 1234567891011121314151617181920212223242526272829303132333435363738394041424344//20msclass Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++)&#123; if(isdigit(board[i][j]))&#123; for(int k=0;k&lt;9;k++)&#123; if(k!=j&amp;&amp;board[i][k]==board[i][j])&#123; return false; &#125; &#125; for(int k=0;k&lt;9;k++)&#123; if(k!=i&amp;&amp;board[k][j]==board[i][j])&#123; return false; &#125; &#125; int temp1=0; if(i&gt;5)&#123; temp1=6; &#125;else if(i&gt;2)&#123; temp1=3; &#125;else&#123; temp1=0; &#125; int temp2=0; if(j&gt;5)&#123; temp2=6; &#125;else if(j&gt;2)&#123; temp2=3; &#125;else&#123; temp2=0; &#125; for(int k=temp1;k&lt;temp1+3;k++)&#123; for(int l=temp2;l&lt;temp2+3;l++)&#123; if(k!=i&amp;&amp;l!=j&amp;&amp;board[k][l]==board[i][j]) return false; &#125; &#125; &#125; &#125; &#125; return true; &#125;&#125;; 因为都是数字，用数组代替哈希表记录每个数字出现的次数，可以建立三个数组也可以用一个数组 12345678910111213141516171819//0msclass Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; // 二维数组 v，共有 27 行，每行有 128 个元素，初始值都为 0 int v[27][128] = &#123;0&#125;;//为啥128？？？？？？？ //前面9行用于存每一行出现的数字次数，中间9行存每一列，最后9行存小九宫格 for(int i = 0; i &lt; 9; ++i) &#123; for(int j = 0; j &lt; 9; ++j) &#123; if(isdigit(board[i][j]) &amp;&amp; (v[i][board[i][j]]++ || v[9+j][board[i][j]]++ || v[18+(i/3)+(j/3)*3][board[i][j]]++)) &#123; // 若出现重复数字-加到2退出，返回 false 除法是舍尾的，每行一个小九宫，竖着依次 return false; &#125; &#125; &#125; return true; &#125;&#125;; 哈希表使用unordered_map 205同构字符串1234567891011121314151617class Solution &#123;public: bool isIsomorphic(string s, string t) &#123; unordered_map&lt;char, char&gt; s2t; unordered_map&lt;char, char&gt; t2s; int len = s.length(); for (int i = 0; i &lt; len; ++i) &#123; char x = s[i], y = t[i]; if ((s2t.count(x) &amp;&amp; s2t[x] != y) || (t2s.count(y) &amp;&amp; t2s[y] != x)) &#123; return false; &#125; s2t[x] = y; t2s[y] = x; &#125; return true; &#125;&#125;; 383 赎金信给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 只需要统计每一个字符出现的次数，ransomNote里面的都要&lt;&#x3D;magazine 12345678910111213141516171819class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; if (ransomNote.size() &gt; magazine.size()) &#123; return false; &#125; vector&lt;int&gt; cnt(26); //用int cnt[26]=&#123;0&#125;;更快 for (auto &amp; c : magazine) &#123; //知道类型的情况下，char比auto快 cnt[c - &#x27;a&#x27;]++; //a 放到0的位置依次 &#125; for (auto &amp; c : ransomNote) &#123; cnt[c - &#x27;a&#x27;]--; if (cnt[c - &#x27;a&#x27;] &lt; 0) &#123; return false; &#125; &#125; return true; &#125;&#125;; ###128 最长连续序列 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 示例 1： 123输入：nums = [100,4,200,1,3,2]输出：4解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 排序-&gt;遍历,下一个是前一位+1继续,遍历的下一位是不是前一位+1 O(n) 哈希表 O(1) 栈stk 回溯-一种递归思路类似深度优先 17 电话号码的字母组合myidea：用二维数组存储映射关系，下标为数字 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; combinations;//存储所有字母组合 if (digits.empty()) &#123; return combinations; &#125; unordered_map&lt;char, string&gt; phoneMap&#123;//哈希表存储映射关系 &#123;&#x27;2&#x27;, &quot;abc&quot;&#125;, &#123;&#x27;3&#x27;, &quot;def&quot;&#125;, &#123;&#x27;4&#x27;, &quot;ghi&quot;&#125;, &#123;&#x27;5&#x27;, &quot;jkl&quot;&#125;, &#123;&#x27;6&#x27;, &quot;mno&quot;&#125;, &#123;&#x27;7&#x27;, &quot;pqrs&quot;&#125;, &#123;&#x27;8&#x27;, &quot;tuv&quot;&#125;, &#123;&#x27;9&#x27;, &quot;wxyz&quot;&#125; &#125;; string combination;//临时字母组合 backtrack(combinations, phoneMap, digits, 0, combination); return combinations; &#125; void backtrack(vector&lt;string&gt;&amp; combinations, const unordered_map&lt;char, string&gt;&amp; phoneMap, const string&amp; digits, int index, string&amp; combination) &#123; if (index == digits.length()) &#123; combinations.push_back(combination); &#125; else &#123; char digit = digits[index];//获取当前字数字 const string&amp; letters = phoneMap.at(digit);//当前数字对应的字母 for (const char&amp; letter: letters) &#123; combination.push_back(letter); backtrack(combinations, phoneMap, digits, index + 1, combination);//递归 combination.pop_back(); &#125; &#125; &#125;&#125;; 12345678910111213141516171819202122class Solution &#123; string MAPPING[10] = &#123;&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;public: vector&lt;string&gt; letterCombinations(string digits) &#123; int n = digits.length();//数字长度 if (n == 0) return &#123;&#125;; vector&lt;string&gt; ans; string path(n, 0); // 临时存储和字母组合 function&lt;void(int)&gt; dfs = [&amp;](int i) &#123; if (i == n) &#123; ans.emplace_back(path);//一般用于不创建临时对象，此处用push_back效果一样 return;//出口 &#125; for (char c : MAPPING[digits[i] - &#x27;0&#x27;]) &#123;//char-&gt;int,遍历该数字对应的每个字符 path[i] = c; // 直接覆盖 dfs(i + 1);//递归 &#125; &#125;; dfs(0);//调用函数，传入i=0 return ans; &#125;&#125;; function&lt;void(int)&gt; dfs = [&amp;](int i)：定义了一个名为 dfs 的函数对象，其参数类型为 int，返回类型为 void。它使用了 Lambda 表达式 &amp; 捕获了当前作用域内的所有变量，这样可以访问外部的变量。 总体来说，这段代码的作用是对输入的数字字符串 digits 进行深度优先搜索，生成所有可能的字母组合，并将结果存储在 ans 中。 77 组合比上一题多一步，就是解决重复的组合 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按 任何顺序 返回答案。 12345678910输入：n = 4, k = 2输出：[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; if(n==0) return&#123;&#125;; vector&lt;int&gt; nums(n); for(int i=0;i&lt;n;i++)&#123; nums[i]=i+1; &#125; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path(k); function&lt;void(int, int)&gt; dfs = [&amp;](int start, int i) &#123; if(i==k)&#123; ans.push_back(path); return ; &#125; for(int j = start; j &lt; nums.size(); j++)&#123; path[i] = nums[j]; dfs(j + 1, i + 1); &#125; &#125;; dfs(0, 0); return ans; &#125;&#125;; 46 全排列传统回溯会有重复情况,用一个数组来标记是否已经被标记，递归完后要回溯标记为false 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n == 0) return &#123;&#125;; vector&lt;int&gt; temp(n); vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;bool&gt; used(n, false); // 记录数字是否被使用过 function&lt;void(int)&gt; dfs = [&amp;](int i) &#123; if (i == n) &#123; ans.push_back(temp); return; &#125; for (int j = 0; j &lt; n; ++j) &#123; if (!used[j]) &#123; temp[i] = nums[j]; used[j] = true; dfs(i + 1); used[j] = false; // 回溯，恢复状态 &#125; &#125; &#125;; dfs(0); return ans; &#125;&#125;;","categories":["刷题"]},{"title":"数字逻辑概论","path":"/2024/06/09/数字逻辑/","content":"数字逻辑概论##数制转换 一位十六进制等效于四位二进制 ##码制转换 &#x3D;&#x3D;8421BCD码&#x3D;&#x3D; 每一个数字用四位二进制数表示 数字的&#x3D;&#x3D;ASCII码&#x3D;&#x3D;表示，低位是对应的四位二进制，高位是011 &#x3D;&#x3D;格雷码&#x3D;&#x3D; 1+1 保留0舍去进位1 ##逻辑运算及逻辑门 列真值表分三列-一组-两组-四组 第一列00001111 第二列00110011 第三列01010101 输入组合为2^n 与(同时为1才是1-并) 或(有1为1-交) + 与非(与相反) 或非 下方是波形 异或(相同为0) 同或 ##使用逻辑门的电路举例 &#x3D;&#x3D;真值表-&gt;逻辑函数表达式&#x3D;&#x3D; 写与或表达式(先*后+)-先看L1-四个为1的数-001看作-A非B非C-为1 &#x3D;&#x3D;逻辑函数表达式-&gt;真值表&#x3D;&#x3D; 异或 &#x3D;&#x3D;逻辑图-&gt;逻辑函数表达式&#x3D;&#x3D; c前面的圆圈代表c要去三个地方 逻辑代数##逻辑代数的基本公式和规则 &#x3D;&#x3D;列真值表证明表达式&#x3D;&#x3D; &#x3D;&#x3D;同逻辑代数定理证明等式&#x3D;&#x3D; 反演规则：+ * 互变 每个取非 0 1互换 对偶规则：+ * 互变 0 1互换 ##逻辑函数的最简形式 与或表达式 部分与整体和 AB+CD 或与表达式 与非-与非 或非-或非 与-或-非 &#x3D;&#x3D;用代数法化简最简与或表达式&#x3D;&#x3D; 逻辑函数表达式的两种标准形式最小项：一个乘积包含所有变量以原变量或非变量的形式 ABC n个变量的最小项有2^n个 用mi表示 最小项编号：原变量用1非变量用0 例如编号011十进制是3表示为m3 最小项表达式&#x2F;标准与或表达式：若干最小项相或 最大项：相加 (A+B) 最小项和最大项取非相等 最大项只有一组取值值为0 任意两个最大想之和为1 所有最大项之积为0 &#x3D;&#x3D;求最小项表达式&#x3D;&#x3D; 逻辑函数卡诺图化简法 &#x3D;&#x3D;用卡诺图化简式子&#x3D;&#x3D; 先求最简与或表达式-画图-得出式子 d代表无关项-随意选择为多少 组合逻辑电路组合逻辑电路分析输出状态只取决于同一时刻的输入，没有反馈延迟通路 电路中不含记忆功能的元件 逐级写逻辑表达式，直到写出输入和输出的逻辑表达式 化简得到最简表达式 列真值表 确定功能 最后一步化简没看懂 组合逻辑电路的设计 真值表 卡诺图 最简表达式 画逻辑图 组合逻辑电路的竞争-冒险优先编码器CD4532多对少 普通编码器允许一个输入信号有效，优先编码器允许多个有效，输出优先级高的 CD4532：8线-3线的优先编码器 译码器 反过来的 ##74HC138译码器 锁存器和触发器锁存器基本SR锁存器的工作基本原理 门控SR锁存器 特性表 锁存器和触发器对上升沿或者下降沿敏感的叫触发器 主从D触发器的电路结构和工作原理 左边cp端有圈是对下降沿敏感的 先分析右边的对上升沿敏感的Q2，开始状态是0，当cp上升时D为0，所以状态不改变，第二次上升时D为1改变，下一次改变又看上升沿D的状态 频率之间的关系 D触发器 JK触发器 T触发器T&#x3D;0保持 T&#x3D;1翻转 时序逻辑电路基本概念 米利型时序电路 输出信号随时可能受到非时钟同步的输入信号改变，影响同步性 穆尔型 同步性不受影响 同步：C1受到同一个输入CP影响 摩尔型：输出只与Q有关 现态为1时，当输入为10，会变为次态1，同时输出1 当为摩尔型时可以将输出也画在圈内 (触发器的)激励方程组-&gt;特征方程-&gt;转换方程组-&gt;输出方程组-&gt;转换表&#x2F;状态表-&gt;状态图-&gt;时序图 D触发器：Q^n+1&#x3D;D JK触发器:Q^n+1&#x3D;JQ^n非+K非Q^n 设计同步时序逻辑电路 寄存器和移位寄存器存储N位二进制数据的寄存器需要N个触发器 计数器的分析与设计模M：计数器开始运行从某一状态依次遍历不不重复的各个状态后完成循环经过的状态总数 在n个状态下循环：模n计数器&#x2F;M&#x3D;n计数器&#x2F;n进制计数器 N位二进制计数器 模为2^n，N个触发器 确定模 画逻辑图 cr清零端，cp 图的分析 集成同步二进制计数器74LVC161 cet cep：使能端 低电平有效预制端PE，低电平有效清零端CR D0-3预制数据输入端 TC进位端 CP时钟脉冲输入端 Q0-3输出端 ###反馈清零法 异步清零功能，只要cr&#x3D;0，瞬间输出端回到0000 （74LVC163是同步清0） 当计数到1001时自动清零回到0000 模为9，9进制计数器0000-1000(9) ？？？？ 反馈置数法 当Q3&#x3D;1，这时等待一个时间脉冲后(同步)置入0000 当输出1111进位TC&#x3D;1","tags":["数字逻辑概论"],"categories":["大学课程"]},{"title":"14届蓝桥杯c/c++b组","path":"/2024/06/09/蓝桥杯刷题/","content":"星迪的气场计算循环读入字符串，单字符串排列，遍历字符串，字符计算 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool compareChars(const char&amp; a, const char&amp; b) &#123; return a &lt; b;&#125;int main()&#123; // 请在此输入您的代码 int n; cin &gt;&gt; n; vector&lt;string&gt; a; for (int i = 0; i &lt; n; i++) &#123; string name; cin &gt;&gt; name; a.push_back(name); //字符串从小到大排序。遍历 sort(name.begin(), name.end(), compareChars); int count = 1; int all = 0; for (string::const_iterator it = name.begin(); it != name.end(); ++it) &#123; all += (*it - 96) * count; count++; &#125; cout &lt;&lt; all &lt;&lt; endl; &#125; return 0;&#125; 数字转换整数转字符串 string str&#x3D;to_string(n); 字符串长度：str.length(); 字符串转整数：int n&#x3D;stoi(str); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool isIncreasing(int n) &#123; string str_n = to_string(n); // 将整数转换为字符串 // 比较字符串中每个字符代表的数值 for (size_t i = 0; i &lt; str_n.length() - 1; ++i) &#123; if (str_n[i] &gt;= str_n[i + 1]) &#123; return false; // 如果当前字符不小于下一个字符，则不是递增的 &#125; &#125; return true; // 所有字符都是递增的 &#125;bool exchange(int n) &#123; string str = to_string(n); int j = str.length(); if (j == 1) &#123; cout &lt;&lt;n&lt;&lt;endl; &#125;else if (j == 2) &#123; if (str[0] &lt; str[1]) &#123; cout &lt;&lt; n &lt;&lt; endl; return true; &#125; else &#123; int temp = str[0]; str[0] = str[1]; str[1] = temp; int end = stoi(str); cout &lt;&lt; end &lt;&lt; endl; return true; &#125; &#125;else &#123; //从左到右遍历两遍，每次比较三个，最小的在第三位交换两次结束，最小的在第二位交换一次，再次遍历 //遇到232结构先不慌，继续找321结构，没有就回滚 for (int i = 0; i &lt; j-2; i++) &#123; if (str[i + 2] &lt; str[i] &amp;&amp; str[i + 2] &lt; str[i + 1]) &#123; int temp1 = str[i]; str[i] = str[i + 2]; str[i + 2] = str[i + 1]; str[i + 1] = temp1; int end = stoi(str); cout &lt;&lt; end &lt;&lt; endl; return true; &#125; else if (str[i + 1] &lt; str[i] &amp;&amp; str[i + 1] &lt; str[i + 2]) &#123; int temp = str[i]; if (str[i] &lt;= str[i + 2]) &#123; str[i] = str[i + 1]; str[i + 1] = temp; &#125; else &#123; str[i] = str[i + 1]; str[i + 1] = str[i + 2]; str[i + 2] = temp; int end = stoi(str); cout &lt;&lt; end &lt;&lt; endl; return true; &#125; &#125; &#125; int end = stoi(str); cout &lt;&lt; end &lt;&lt; endl; return true; &#125;&#125;int main()&#123;\tint number;\tcin &gt;&gt; number; if (isIncreasing(number)) &#123; //不交换 cout &lt;&lt; number&lt;&lt; endl; &#125; else &#123; exchange(number); &#125;\treturn 0;&#125; 01串的熵计算对数： #include log2(a) 比较浮点数： fabs(res - 11625907.5798) &lt; 0.0001 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n = 23333333; for (int i = 1; i &lt; n; ++i) &#123; double a = i * 1.0 / n; // 0出现的占比 double b = (n - i) * 1.0 / n; // 1出现的占比 double res = 0; res -= a * log2(a) * i + b * log2(b) * (n - i); if (fabs(res - 11625907.5798) &lt; 0.0001) &#123; cout &lt;&lt; i &lt;&lt; endl; break; &#125; &#125; return 0;&#125; 冶炼金属二维数组： vector&lt;vector&gt; num(n, vector(2)); 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;//#include &lt;algorithm&gt;using namespace std;int main()&#123; // 请在此输入您的代码 int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; num(n, vector&lt;int&gt;(2)); int a[2] = &#123;0&#125;; for (int i = 0; i &lt; n; i++) &#123; int j; cin &gt;&gt; j; int k; cin &gt;&gt; k; num[i][0] = j; num[i][1] = k; int temp = j / k; if (temp &lt; a[1]) &#123; a[1] = temp; &#125; if (i == 0) &#123; a[1] = temp; &#125; &#125; int k = a[1]; int flag = 0; while (k != 0) &#123; k--; for (int i = 0; i &lt; n; i++) &#123; if (num[i][0] / k != num[i][0] / a[1]) &#123; a[0] = k + 1; flag = 1; break; &#125; &#125; if (flag == 1) &#123; break; &#125; &#125; cout &lt;&lt; a[0] &lt;&lt; &quot; &quot; &lt;&lt; a[1] &lt;&lt; endl; return 0;&#125; 飞机降落一种很好的循环结构 int T;cin &gt;&gt; T; while (T--)&#123;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 创建飞机结构体变量struct plane&#123; int t, d, l;&#125;;bool vis[15]; // true表示飞机降落，false表示飞机未降落bool flag; // 标记是否全部安全降落vector&lt;plane&gt; p(15);// 深搜void dfs(int m, int cnt, int last) // last表示此前所有飞机降落所需的单位时间&#123; if (cnt == m) &#123; flag = true; return; &#125; for (int i = 0; i &lt; m; i++) &#123; if (!vis[i] &amp;&amp; p[i].t + p[i].d &gt;= last) // 只有来的时刻+盘旋时间 &gt; last 的飞机才可以安全降落 &#123; vis[i] = true; dfs(m, cnt + 1, max(last, p[i].t) + p[i].l); vis[i] = false; &#125; &#125;&#125;int main()&#123; int T; cin &gt;&gt; T; while (T--) &#123; int N; cin &gt;&gt; N; for (int i = 0; i &lt; N; ++i) cin &gt;&gt; p[i].t &gt;&gt; p[i].d &gt;&gt; p[i].l; flag = false; dfs(N, 0, 0); if (flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125; 接龙问题读字符串：遇空格就会停 字符串转数字：int x &#x3D; s[0] - ‘0’, y &#x3D; s[s.size() - 1] - ‘0’; 动态规划DP：重叠子问题，最优子结构问题(递归) 目的：找最长的接龙数列 关系：从后往前看，第i个数的最长子序列数为以第i个数的首位为尾数的那个数的最长序列+1 用一个数组来dp[i]表示以i为尾数字的最长序列 x表示首位，y表示尾数 dp[y]&#x3D;max(dp[x]+1,dp[y]); n记录最大的子序列n&#x3D;max(dp[y],n); 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int dp[10];int main()&#123; // 请在此输入您的代码 int n; cin &gt;&gt; n; string s; int m = 0; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; s; int x = s[0] - &#x27;0&#x27;, y = s[s.size() - 1] - &#x27;0&#x27;; dp[y] = max(dp[x] + 1, dp[y]); m = max(m, dp[y]); &#125; cout &lt;&lt; n - m &lt;&lt; endl; return 0;&#125; 岛屿个数vector&lt;vector&gt; data(m + 2, vector(n + 2, ‘0’)); 二维全部赋0 深度优先DFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int deltaOfSea[8][2] = &#123;&#123;-1, -1&#125;,&#123;-1, 0&#125;,&#123;-1, 1&#125;,&#123;0, 1&#125;,&#123;1, 1&#125;,&#123;1, 0&#125;,&#123;1, -1&#125;,&#123;0, -1&#125;&#125;;//一格的八个方向int deltaOfIsland[4][2] = &#123;&#123;-1, 0&#125;,&#123;1, 0&#125;,&#123;0, -1&#125;,&#123;0, 1&#125;&#125;;//四个方向int ans = 0;void DFS_Island(vector&lt;vector&lt;char&gt;&gt;&amp; data, int r, int c, int m, int n)&#123; data[r][c] = &#x27;N&#x27;; for(int i = 0; i &lt; 4; ++i)&#123;//岛只看四个方向 int newR = r + deltaOfIsland[i][0]; int newC = c + deltaOfIsland[i][1]; if(newR &gt;= 0 &amp;&amp; newR &lt; m &amp;&amp; newC &gt;= 0 &amp;&amp; newC &lt; n)&#123; if(data[newR][newC] == &#x27;1&#x27;) DFS_Island(data, newR, newC, m, n); &#125; &#125;&#125;void DFS_Sea(vector&lt;vector&lt;char&gt;&gt;&amp; data, int r, int c, int m, int n)&#123; data[r][c] = &#x27;N&#x27;; //r c记录当前访问的位置 N记作已经访问 for(int i = 0; i &lt; 8; ++i)&#123;//遍历当前位置的8个方向 int newR = r + deltaOfSea[i][0]; int newC = c + deltaOfSea[i][1]; if(newR &gt;= 0 &amp;&amp; newR &lt; m &amp;&amp; newC &gt;= 0 &amp;&amp; newC &lt; n)&#123;//当前相邻单元格有效 if(data[newR][newC] == &#x27;1&#x27;)&#123; DFS_Island(data, newR, newC, m, n);//找岛屿 ++ans; &#125; else if(data[newR][newC] == &#x27;0&#x27;)&#123; DFS_Sea(data, newR, newC, m, n); &#125; &#125; &#125;&#125;int main()&#123; int t; cin &gt;&gt; t; vector&lt; vector&lt;vector&lt;char&gt;&gt; &gt; datas;//用三维存储每一个二维 for(int i = 0; i &lt; t; ++i)&#123; int m, n; cin &gt;&gt; m &gt;&gt; n; vector&lt;vector&lt;char&gt;&gt; data(m + 2, vector&lt;char&gt;(n + 2, &#x27;0&#x27;)); //扩展一圈0，防止遍历不完，可以 for(int r = 1; r &lt; m + 1; ++r)&#123; for(int c = 1; c &lt; n + 1; ++c)&#123; cin &gt;&gt; data[r][c]; &#125; &#125; datas.push_back(data); &#125; for(int i = 0; i &lt; t; ++i)&#123; vector&lt;vector&lt;char&gt;&gt; data = datas[i]; int m = data.size(); int n = data[0].size(); DFS_Sea(data, 0, 0, m, n); cout &lt;&lt; ans &lt;&lt; endl; ans = 0; &#125; return 0;&#125; 字串简写正常暴力只能解决70% 思路：正向统计a数目，遇到b则将之前统计的长度加到ans上 123456789101112131415#include &lt;bits/stdc++.h&gt; using namespace std;int K;long long ans=0,c1_sum=0;string S;char c1,c2;int main()&#123; cin&gt;&gt;K&gt;&gt;S&gt;&gt;c1&gt;&gt;c2; for(int i=K-1,j=0;i&lt;S.length();i++,j++)&#123; if(S[j]==c1) c1_sum++; if(S[i]==c2) ans+=c1_sum; &#125; cout&lt;&lt;ans; return 0;&#125; 整数删除#include 找最值，排序 12345678910111213141516171819202122232425262728293031323334353637//30%#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;\tint n,k; cin &gt;&gt; n&gt;&gt;k;\tvector&lt;int&gt; a;\tfor (int i = 0; i &lt; n; i++) &#123; int temp; cin &gt;&gt; temp; a.push_back(temp);\t&#125;\tfor (int i = 0; i &lt; k; i++) &#123; auto minelement = min_element(a.begin(), a.end()); int min = *minelement; for (vector&lt;int&gt;::iterator it = a.begin(); it != a.end(); ++it) &#123; if (*it == min) &#123; vector&lt;int&gt;::iterator prev = it; vector&lt;int&gt;::iterator next = it; if (it != a.begin()) &#123; --prev; *prev += min; &#125; ++next; if (next != a.end()) &#123; *next += min; &#125; a.erase(it); break; &#125; &#125;\t&#125;\tfor (int i:a) &#123; cout &lt;&lt; i &lt;&lt; &#x27; &#x27;;\t&#125;\treturn 0;&#125; 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;int main() &#123; int n, k; std::cin &gt;&gt; n &gt;&gt; k; std::vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; ++i) &#123; std::cin &gt;&gt; a[i]; &#125; for (int i = 0; i &lt; k; ++i) &#123; auto minIt = std::min_element(a.begin(), a.end());// int minIndex = std::distance(a.begin(), minIt);//这两处每次需要遍历找很浪费 int min = *minIt; if (minIndex &gt; 0) &#123; a[minIndex - 1] += min; &#125; if (minIndex &lt; n - 1) &#123; a[minIndex + 1] += min; &#125; a.erase(a.begin() + minIndex);//费时间 &#125; for (int i : a) &#123; std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; 使用优先队列（最小堆）维护元素和索引，log时间内找最小值 更新后的元素和索引放入堆中，最小值被标记为INT_MAX 声明优先队列 priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;,greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; 队列中的元素类型为pair，选择vector容器，比较器greater，函数对象，按&gt;运算符，顶部(最小)有最大的权重，没有比较器默认顶部最小权重 插入数据 pq.push(&#123; a[i], i &#125;); 取数据 auto [min, minIndex] = pq.top(); 移除顶部元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;functional&gt;#include &lt;climits&gt;using namespace std;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; a(n); priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; vector&lt;int&gt; c(n); vector&lt;int&gt; d(n); vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a[i]; pq.push(&#123; a[i], i &#125;); c[i] = i - 1; d[i] = i + 1; &#125; //创建两个数组实时更新每个数左右最近的下标，更新堆的时候就能快速定位到了 //一个数组用来记录当前数据修改的次数，出栈一次则修改次数-1 while (k-- &gt; 0 &amp;&amp; !pq.empty()) &#123; auto [min, minIndex] = pq.top(); cout &lt;&lt; min &lt;&lt; &#x27; &#x27; &lt;&lt; minIndex &lt;&lt; endl; pq.pop(); if (nums[minIndex]==0) &#123; //删除 int temp1 = c[minIndex]; int temp2 = d[minIndex]; if (temp1 != -1) &#123; a[temp1] += min; d[temp1] = temp2; pq.push(&#123; a[temp1], temp1 &#125;);//更新 nums[temp1]++;//修改次数+1 &#125; if (temp2 != n) &#123; a[temp2] += min; c[temp2] = temp1; pq.push(&#123; a[temp2], temp2 &#125;); nums[temp2]++; &#125; // 标记最小元素为已处理 a[minIndex] = INT_MAX; &#125; else if (nums[minIndex] != 0) &#123; //修改次数-1 k++; nums[minIndex]--; &#125; &#125; // 输出未被标记为已处理的元素 for (int i = 0; i &lt; n; ++i) &#123; if (a[i] != INT_MAX) &#123; cout &lt;&lt; a[i] &lt;&lt; &#x27; &#x27;; &#125; &#125; return 0;&#125; 景区导游LCA：最近公共祖先 暴力：一层一层跳，lca：倍增 DFS：深度优先搜索root-&gt;a BFS:广度优先 a-b的距离&#x3D;root-&gt;a+root-&gt;b-2*root-&gt;lca 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int N = 1e5 + 100;//10^5+100int n, k;int deep[N]; // 深度int dp[N][21]; // dp[i][j]表示从i结点开始跳2^j步可到达的结点vector&lt;int&gt; edge[N]; // 边vector&lt;int&gt; weight[N]; // 权值ll path[N]; // 原始的游览路线ll dist[N]; // dist[i]存储i到根结点的距离void dfs(int u, int father) // LCA的前置算法(模板) 层数 父亲节点&#123; deep[u] = deep[father] + 1; dp[u][0] = father; for (int i = 1; i &lt;= 20; i++) &#123; dp[u][i] = dp[dp[u][i - 1]][i - 1]; &#125; for (size_t i = 0; i &lt; edge[u].size(); i++) &#123; int v = edge[u][i], w = weight[u][i]; if (v == father) continue; dist[v] = dist[u] + w; dfs(v, u); //下一层递归 &#125;&#125;int LCA(int x, int y) // 求x和y的最近公共祖先(模板)&#123; if (deep[x] &lt; deep[y]) swap(x, y); for (int i = 20; i &gt;= 0; i--) &#123; if (deep[dp[x][i]] &gt;= deep[y]) &#123; x = dp[x][i]; &#125; &#125; if (x == y) return x; for (int i = 20; i &gt;= 0; i--) &#123; if (dp[x][i] != dp[y][i]) &#123; x = dp[x][i]; y = dp[y][i]; &#125; &#125; return dp[x][0];&#125;ll get_dist(int x, int y) // 求x和y的距离&#123; if (x == 0 || y == 0) return 0; return dist[x] + dist[y] - 2 * dist[LCA(x, y)];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt; n; i++) // 插入n-1条无向边 &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; edge[u].push_back(v); edge[v].push_back(u); weight[u].push_back(w); weight[v].push_back(w); &#125; dfs(1, 0); // 跑一遍dfs为LCA做准备 ll sum = 0; // sum存储原始游览路线的总路径长度 for (int i = 1; i &lt;= k; i++) &#123; cin &gt;&gt; path[i]; if (i &gt; 1) // 从第二个景点开始计算 &#123; sum += get_dist(path[i], path[i - 1]); // 依次累加 &#125; &#125; for (int i = 1; i &lt;= k; i++) // 除去第i个景点 &#123; ll dist1 = get_dist(path[i], path[i - 1]); ll dist2 = get_dist(path[i], path[i + 1]); ll dist3 = get_dist(path[i - 1], path[i + 1]); cout &lt;&lt; sum - dist1 - dist2 + dist3 &lt;&lt; &quot; &quot;; // 套公式计算即可 &#125; cout &lt;&lt; endl; return 0;&#125; 基础算法：枚举 贪心 模拟二分 排序：桶排序 归并排序 快速排序 搜索：DFS BFS 剪枝 动态规划：一维dp 背包dp 树形dp 状压dp 数位dp","tags":["蓝桥杯"],"categories":["算法"]},{"title":"c++面试","path":"/2024/06/09/C++面试准备/","content":"RPC：是一种允许程序调用另一个地址空间（通常在另一台共享网络的计算机上）的程序的技术，就像调用本地子程序一样 数据序列化：数据序列化是将数据结构或对象状态转换成可以存储或传输的格式的过程。通过序列化，复杂的数据结构可以被转换为字节流，从而便于存储到文件、数据库，或者通过网络传输。json xml 反序列化则是将字节流恢复成原始数据结构或对象状态的过程。 网络传输用的大端 c++20 协程 比线程更小的 引用和指针123456int x=10;int *p=&amp;x;int &amp;y=x;int z=*p;使用需要解引用int z=y; y是x的别名 目前计划-&gt;看stl库-&gt;实现数据结构部分-&gt; 顺序容器 **std::vector**： 动态数组，可以随机访问元素，支持高效的尾部插入和删除操作。 12cpp复制代码#include &lt;vector&gt;std::vector&lt;int&gt; vec; **std::deque**： 双端队列，支持高效的头部和尾部插入和删除操作。 12cpp复制代码#include &lt;deque&gt;std::deque&lt;int&gt; deq; **std::list**： 双向链表，支持高效的插入和删除操作，但不支持随机访问。 12cpp复制代码#include &lt;list&gt;std::list&lt;int&gt; lst; **std::forward_list**： 单向链表，仅支持单向遍历，节省空间。 12cpp复制代码#include &lt;forward_list&gt;std::forward_list&lt;int&gt; fwd_lst; 关联容器 **std::map**： 有序关联容器，存储键值对，键是唯一的，按照键的顺序排序。 12cpp复制代码#include &lt;map&gt;std::map&lt;int, std::string&gt; mp; **std::multimap**： 有序关联容器，允许键重复，按照键的顺序排序。 12cpp复制代码#include &lt;map&gt;std::multimap&lt;int, std::string&gt; mmp; **std::set**： 有序集合，存储唯一的元素，按照元素的顺序排序。 12cpp复制代码#include &lt;set&gt;std::set&lt;int&gt; st; **std::multiset**： 有序集合，允许元素重复，按照元素的顺序排序。 12cpp复制代码#include &lt;set&gt;std::multiset&lt;int&gt; mst; 无序容器 **std::unordered_map**： 无序关联容器，存储键值对，键是唯一的，基于哈希表实现。 12cpp复制代码#include &lt;unordered_map&gt;std::unordered_map&lt;int, std::string&gt; ump; **std::unordered_multimap**： 无序关联容器，允许键重复，基于哈希表实现。 12cpp复制代码#include &lt;unordered_map&gt;std::unordered_multimap&lt;int, std::string&gt; ummp; **std::unordered_set**： 无序集合，存储唯一的元素，基于哈希表实现。 12cpp复制代码#include &lt;unordered_set&gt;std::unordered_set&lt;int&gt; ust; **std::unordered_multiset**： 无序集合，允许元素重复，基于哈希表实现。 12cpp复制代码#include &lt;unordered_set&gt;std::unordered_multiset&lt;int&gt; umst; 容器适配器 **std::stack**： 栈适配器，通常基于 std::deque 实现，也可以基于 std::vector 或 std::list 实现。 12cpp复制代码#include &lt;stack&gt;std::stack&lt;int&gt; stk; **std::queue**： 队列适配器，通常基于 std::deque 实现。 12cpp复制代码#include &lt;queue&gt;std::queue&lt;int&gt; que; **std::priority_queue**： 优先队列适配器，通常基于 std::vector 实现，用于维护一个堆结构。 12cpp复制代码#include &lt;queue&gt;std::priority_queue&lt;int&gt; pq; 特殊容器 **std::array**： 定长数组，大小在编译时确定。 12cpp复制代码#include &lt;array&gt;std::array&lt;int, 10&gt; arr; **std::bitset**： 定长二进制数组，用于高效存储和操作二进制位。 12cpp复制代码#include &lt;bitset&gt;std::bitset&lt;8&gt; bs; 选择合适的容器选择合适的容器取决于具体需求： 需要随机访问：std::vector 或 std::deque 需要高效的头尾部插入&#x2F;删除：std::deque 需要高效的任意位置插入&#x2F;删除：std::list 或 std::forward_list 需要键值对存储且按键排序：std::map 需要键值对存储且按哈希表存储：std::unordered_map 需要存储唯一元素且按顺序排序：std::set 需要存储唯一元素且按哈希表存储：std::unordered_set 需要LIFO结构：std::stack 需要FIFO结构：std::queue 需要优先级队列：std::priority_queue","tags":["c++面试"],"categories":["就业"]},{"title":"Qt面试","path":"/2024/06/09/Qt面试准备/","content":"核心机制元对象系统 (信号与槽 运行时类型信息 动态属性) ​\t直接或间接继承QObject可以使用 ​\t声明Q_OBJECT宏 ​\t元对象编译器moc 将代码转化给c++编译器 属性系统 信号与槽 Qt创建多线程的方式 QThread 最方便 可开启事件循环 可信号 123QThread *t=new QThread;server * worker=new server;worker-&gt;moveToThread(t); 新建一个类继承自Qthread 这样可以通过构造函数传递参数 12server *serverthread=new server(seed,myserver-&gt;nextPendingConnection());serverthread-&gt;start(); QtConcurrent::run() 在单独的线程中异步处理事务 更简洁方便 12345678QT += core gui concurrent QFuture&lt;void&gt; future = QtConcurrent::run([this]() &#123; //或调用一个函数 // Simulate a long-running task QThread::sleep(5); // Sleep for 5 seconds // Update the label text (this part runs in the main thread) QMetaObject::invokeMethod(this, &quot;updateLabel&quot;, Qt::QueuedConnection); &#125;); QThreadPool 和 QRunnable 适合多个对象和复杂情况 12345678910111213MyTask *task = new MyTask(label);QThreadPool::globalInstance()-&gt;start(task);class MyTask : public QRunnable &#123;public: MyTask(QLabel *label) : m_label(label) &#123;&#125; void run() override &#123; // Simulate a long-running task QThread::sleep(5); // Sleep for 5 seconds QMetaObject::invokeMethod(m_label, &quot;setText&quot;, Qt::QueuedConnection,Q_ARG(QString, &quot;Task Completed!&quot;)); &#125;private: QLabel *m_label;&#125;; 信号与槽类似观察者模式 对象间传递消息：回调函数 MFC就是使用这个 使用函数指针 不保证类型安全 12345678910void printWelcome(int len)&#123;printf(&quot;欢迎欢迎 -- %d/n&quot;, len);&#125;void printGoodbye(int len)&#123;printf(&quot;送客送客 -- %d/n&quot;, len);&#125;void callback(int times, void(*print)(int))&#123;\tint i;\tfor (i = 0; i &lt; times; ++i) &#123; print(i); &#125;\tprintf(&quot;/n我不知道你是迎客还是送客!/n/n&quot;);&#125;\tvoid main(void)&#123;\tcallback(2, printWelcome); callback(2, printGoodbye);&#125; 对象树：自动有效管理继承自QObject的Qt对象 父对象被析构时子对象也析构 避免内存泄漏 1234567891011121314151617signalsemitslots 可以不用声明这个关键字，但是一般需要设置connect的第五个参数可以不用阻塞等待槽函数完成执行//两个原型：connect(pushButton, SIGNAL(clicked()), dialog, SLOT(close()));connect(pushButton, &amp;QPushButton::clicked, dialog, &amp;QDialog::close);//信号发送者指针，信号函数字符串/信号函数地址，槽//lambda表达式connect(anysocket, &amp;QTcpSocket::disconnected, this, [=]() &#123; &#125;);//同一个类中的匿名函数connect(this, &amp;A::sig_hello, []&#123; qDebug() &lt;&lt; &quot;hello world!&quot;;&#125;); 可通过ui界面绑定信号与槽 https://blog.csdn.net/ddllrrbb/article/details/88374350 QSignalMapper 绑定对象数据一并传递 第五个参数： 事件过滤器重写eventFilter方法 不会处理这个信号 给QApplication安装，实现全局 12345678910111213bool eventFilter(QObject *watched, QEvent *event) override &#123; if (event-&gt;type() == QEvent::MouseButtonPress) &#123; qDebug() &lt;&lt; &quot;Button clicked&quot;; // 处理事件，返回 true 表示事件已经被处理，不需要继续传播 return true; &#125; // 其他事件，继续传播 return QObject::eventFilter(watched, event); &#125;MyEventFilter *eventFilter = new MyEventFilter();// 在按钮上安装事件过滤器button-&gt;installEventFilter(eventFilter); 保证线程安全 互斥量（QMutex）QMutex m_Mutex; m_Mutex.lock(); m_Mutex.unlock(); 互斥锁（QMutexLocker）QMutexLocker mutexLocker(&amp;m_Mutex);从声明处开始（在构造函数中加锁），出了作用域自动解锁（在析构函数中解锁）。 等待条件（QWaitCondition）QWaitCondtion m_WaitCondition; m_WaitConditon.wait(&amp;m_muxtex, time);m_WaitCondition.wakeAll(); QReadWriteLock类》一个线程试图对一个加了读锁的互斥量进行上读锁，允许；》一个线程试图对一个加了读锁的互斥量进行上写锁，阻塞；》一个线程试图对一个加了写锁的互斥量进行上读锁，阻塞；、》一个线程试图对一个加了写锁的互斥量进行上写锁，阻塞。读写锁比较适用的情况是：需要多次对共享的数据进行读操作的阅读线程。QReadWriterLock 与QMutex相似，除了它对 “read”,”write”访问进行区别对待。它使得多个读者可以共时访问数据。使用QReadWriteLock而不是QMutex，可以使得多线程程序更具有并发性。 信号量QSemaphore但是还有些互斥量（资源）的数量并不止一个，比如一个电脑安装了2个打印机，我已经申请了一个，但是我不能霸占这两个，你来访问的时候如果发现还有空闲的仍然可以申请到的。于是这个互斥量可以分为两部分，已使用和未使用。 QReadLocker便利类和QWriteLocker便利类对QReadWriteLock进行加解锁 其他QT中的智能指针封装为QPointer类 文件流 文件流(QTextStream):操作轻量级数据（int,double,QString）数据写入文本件中以后以文本的方式呈现。数据流(QDataStream):通过数据流可以操作各种数据类型，包括对象，存储到文件中数据为二进制。 文件流，数据流都可以操作磁盘文件，也可以操作内存数据。通过流对象可以将对象打包到内存，进行数据的传输。 post请求 Qt如何发送一个HTTP post请求并接收消息？在pro文件添加network模块（使用qmake时）使用网络连接请求类(QNetworkRequest)，添加URL网址，并设置HTTP的头部行使用网络访问管理器类(QNetworkAccessManager)发送post请求，同时需要添加HTTP附属体内容，返回得到网络回复类(QNetworkReply)对象当网络回复对象收到返回的消息时会触发相应的信号，可以通过连接槽函数，在槽函数中获取返回的数据","tags":["qt"],"categories":["就业"]},{"title":"windows虚拟机","path":"/2024/06/09/VMware win11/","content":"开始-搜索“启用或关闭windows功能”-勾选“windows虚拟机监控程序平台”和“虚拟机平台” 下载win11 ISODownload Windows 11 (microsoft.com)版本任意 下载wmware此处不展示新建虚拟机-兼容性workstation 16.x -典型-稍后安装操作系统-windows-版本 win11 x64-虚拟机名称&#x2F;位置-固件类型UEFI-只有支持tmp..加密-设置8位以上密码-记住密码-最大磁盘大小64gb-将虚拟机拆分成多个文件-自定义硬件-关闭-完成 我设置的密码：！niubiplus007 设置-选项-访问控制-加密 ​ -高级-固件类型-UEFI -硬件-添加-可信平台模块 -CD&#x2F;DVD-使用ISO映像文件-设备状态-已连接启动时连接 -内存-4GB(4096MB) 我没有产品密钥-win11专业版-自定义安装-不分区 登录账号直接输入错误的账号和密码，用名字登录 下方黄色提示栏或者右键安装vmware tools-win+r-D:\\setup.exe-典型安装 可以直接使用复制粘贴包括文件，拉伸比例 网络配置-一起配好了的这里是192.168.6.129 g++ server.cpp -lpthread -lws2_32 https://blog.csdn.net/qq_42417071/article/details/137438374","tags":["win+vmware"],"categories":["虚拟机"]},{"title":"HTML+CSS","path":"/2024/06/09/Web HTML5 CSS3/","content":"vscode 安装插件 open in browser #HTML ##标签 标签 123&lt;strong&gt;内容&lt;/strong&gt;&lt;br&gt; &lt;!-- 换行 --&gt; 注释：ctrl+/&lt;hr&gt; &lt;!-- 水平线 --&gt; 右键open in browser或者alt+b ###html骨架 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 网页主体 &lt;/body&gt;&lt;/html&gt; 在vscode中 !+enter&#x2F;tab自动生成骨架 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 标签的关系：父子集，平行 ###标题 h1~h6 双标签 h1只用一次 ###段落 p 双 段落之间有空隙 ###文本格式化 ###图像标签 图片的大小一般用css控制 路径 相对：从当前文件夹出发 . .. 绝对：win：从盘 ios：从根出发 C:&#x2F; 可以用在线网站的图片网址 ###超链接 12&lt;a href=&quot;#&quot;&gt;空链接&lt;/a&gt;&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;text&lt;/a&gt; 新窗口打开 ###音频标签 后三个属性都可以简写 引号里面的内容和名字一样 ###视频标签 ###列表-排列整齐 无序ul嵌套li 有序ol嵌套li 定义列表dl嵌套dt标题 dd ###表格 包裹住tr即可，但是视觉上没变化 合并单元格 ###表单-收集用户信息 input 占位文本-提示 placeholder&#x3D;”” 其他属性 file multitiple可以多选上传 checkbox checked 下拉菜单 ###文本域 多行输入 textarea 双 ###label标签 双 绑定文字和表单控件的关系，增大表单控件的点击范围 按钮button ###无语义布局标签 div 独占一行 大盒子(可以换行展示内容) span 不换行 小盒子(不换行展示) 字符实体 多个键盘空格网页上只有一个 CSS层叠样式表 引入方式内部 css写在style标签里面 外部 单独放 .css html使用link标签引入 行内 配合Javascript使用 123&lt;div style=&quot;color: blueviolet;font-size: 30px;&quot;&gt; test2 &lt;/div&gt;","tags":["HTML","CSS"],"categories":["开发"]},{"title":"微信公众号开发","path":"/2024/06/09/微信公众号开发/","content":"一开始比较好奇如何实现公众号上点击按钮返回查询当地的天气这个功能，加上想要知道如何调用api接口进行开发，还有对网页的一些疑问？ 我注册了一个公众号，网址应该是这个：https://mp.weixin.qq.com 设置与开发-公众号设置-功能设置中有一个JS接口安全域名设置 只要我绑定这个应该就可以进行开发了 但是我没有域名？ 域名通过ICP备案？ 现在我留有两个问题 我搜到的资料： 点击发送天气预报的js代码：https://cloud.tencent.com/developer/article/1676360 阿里云ICP备案网址(免费)：https://beian.aliyun.com/?spm=5176.27043851.J_5642934430.8.27b175baCO8rQF 遇事不决还是看看官方文档 设置与开发-开发者工具-开发者文档 https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Getting_Started_Guide.html 基本配置 购买云服务器 √ 搭建服务 python官网下载压缩包https://www.python.org/downloads/source/ 选择第二个xz版本，下载后传到&#x2F;home&#x2F;myhome 下载python python –version没有,但是whereis python显示python3.6说明我已经有了，我需要使用python3指令 python3 –version √ pip3 install web-py √ yum install libxml2 libxslt √ 这个原本就有了的 pip3 install lxml √ vim main.py # -*- coding: utf-8 -*- # filename: main.py import web urls = ( &#39;/wx&#39;, &#39;Handle&#39;, ) class Handle(object): def GET(self): return &quot;hello, this is handle view&quot; if __name__ == &#39;__main__&#39;: app = web.application(urls, globals()) app.run() 12345678910111213141516171819202122232425262728* python3 main.py 80* 访问http://localhost/wx会出现hello, this is handle view3. 开发者基本配置* 修改配置* URL：http://47.115.215.143/wx* Token：123456xxx* 随机生成EncodingAESKey:livQRyv3bSWTW8qW3llMVPNsnhi50maBaPinbfOnJcu* 改动main.py* ~~~py # -*- coding: utf-8 -*- # filename: main.py import web from handle import Handle urls = ( &#x27;/wx&#x27;, &#x27;Handle&#x27;, ) if __name__ == &#x27;__main__&#x27;: app = web.application(urls, globals()) app.run() vim handle.py 这里微信平台提供的是错的，也是有点无语了 # -*- coding: utf-8 -*- # filename: handle.py import hashlib import web class Handle(object): def GET(self): try: data = web.input() if len(data) == 0: return &quot;hello, this is handle view&quot; signature = data.signature timestamp = data.timestamp nonce = data.nonce echostr = data.echostr token = &quot;123456xxx&quot; #请按照公众平台官网\\基本配置中信息填写 list = [token, timestamp, nonce] list.sort() tmp_str = &#39;&#39;.join(list) hashcode = hashlib.sha1(tmp_str.encode(&#39;utf-8&#39;)).hexdigest() #sha1 = hashlib.sha1() #map(sha1.update, list) #hashcode = sha1.hexdigest() print (&quot;handle/GET func: hashcode, signature: &quot;, hashcode, signature) if hashcode == signature: return int(echostr) else: return &quot;&quot; except Exception as Argument: return Argument 123456789101112131415161718192021222324252627282930* python3 main.py 80* 提交* 启动[微信公众号 | 如何设置JS-API对接微信高级能力 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/149965575)关注自动回复消息：[koa2实现微信公众号关注自动回复消息-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1672853)[微信公众号网页授权域名和JS接口安全域名配置攻略_域名不匹配当前服务号的js安全域名-CSDN博客](https://blog.csdn.net/hadues/article/details/106639473)[微信公众号网页开发——授权登录，js安全域名，jssdk使用 - web_study - 博客园 (cnblogs.com)](https://www.cnblogs.com/web-wjg/p/11346656.html)# 实现你问我答粉丝给公众号发送文本消息：“欢迎开启公众号开发者模式”，在开发者后台，收到公众平台发送的xml 如下：（下文均隐藏了ToUserName 及 FromUserName 信息）~~~xml&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1460537339&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[欢迎开启公众号开发者模式]]&gt;&lt;/Content&gt; &lt;MsgId&gt;6272960105994287618&lt;/MsgId&gt;&lt;/xml&gt; 公众号想回复给粉丝一条文本消息，内容为“test”, 那么开发者发送给公众平台后台的xml 内容如下： 1234567&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;1460541339&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[test]]&gt;&lt;/Content&gt;&lt;/xml&gt; 收到粉丝消息后不想或者不能5秒内回复时，需回复“success”字符串，如果能不需要回复 如果开发者不进行回复，微信后台没办法确认开发者已收到消息 三次重试后，依旧没有及时回复任何内容，系统自动在粉丝会话界面出现错误提示“该公众号暂时无法提供服务，请稍后再试”。 vim handle.py 12345678910111213141516171819202122232425# -*- coding: utf-8 -*-# # filename: handle.pyimport hashlibimport replyimport receiveimport webclass Handle(object): def POST(self): try: webData = web.data() print &quot;Handle Post webdata is &quot;, webData #后台打日志 recMsg = receive.parse_xml(webData) if isinstance(recMsg, receive.Msg) and recMsg.MsgType == &#x27;text&#x27;: toUser = recMsg.FromUserName fromUser = recMsg.ToUserName content = &quot;test&quot; replyMsg = reply.TextMsg(toUser, fromUser, content) return replyMsg.send() else: print &quot;暂且不处理&quot; return &quot;success&quot; except Exception, Argment: return Argment vim receive.py 123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf-8 -*-## filename: receive.pyimport xml.etree.ElementTree as ETdef parse_xml(web_data): if len(web_data) == 0: return None xmlData = ET.fromstring(web_data) msg_type = xmlData.find(&#x27;MsgType&#x27;).text if msg_type == &#x27;text&#x27;: return TextMsg(xmlData) elif msg_type == &#x27;image&#x27;: return ImageMsg(xmlData)class Msg(object): def __init__(self, xmlData): self.ToUserName = xmlData.find(&#x27;ToUserName&#x27;).text self.FromUserName = xmlData.find(&#x27;FromUserName&#x27;).text self.CreateTime = xmlData.find(&#x27;CreateTime&#x27;).text self.MsgType = xmlData.find(&#x27;MsgType&#x27;).text self.MsgId = xmlData.find(&#x27;MsgId&#x27;).textclass TextMsg(Msg): def __init__(self, xmlData): Msg.__init__(self, xmlData) self.Content = xmlData.find(&#x27;Content&#x27;).text.encode(&quot;utf-8&quot;)class ImageMsg(Msg): def __init__(self, xmlData): Msg.__init__(self, xmlData) self.PicUrl = xmlData.find(&#x27;PicUrl&#x27;).text self.MediaId = xmlData.find(&#x27;MediaId&#x27;).text vim reply.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*- coding: utf-8 -*-## filename: reply.pyimport timeclass Msg(object): def __init__(self): pass def send(self): return &quot;success&quot;class TextMsg(Msg): def __init__(self, toUserName, fromUserName, content): self.__dict = dict() self.__dict[&#x27;ToUserName&#x27;] = toUserName self.__dict[&#x27;FromUserName&#x27;] = fromUserName self.__dict[&#x27;CreateTime&#x27;] = int(time.time()) self.__dict[&#x27;Content&#x27;] = content def send(self): XmlForm = &quot;&quot;&quot; &lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[&#123;ToUserName&#125;]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[&#123;FromUserName&#125;]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;&#123;CreateTime&#125;&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[&#123;Content&#125;]]&gt;&lt;/Content&gt; &lt;/xml&gt; &quot;&quot;&quot; return XmlForm.format(**self.__dict)class ImageMsg(Msg): def __init__(self, toUserName, fromUserName, mediaId): self.__dict = dict() self.__dict[&#x27;ToUserName&#x27;] = toUserName self.__dict[&#x27;FromUserName&#x27;] = fromUserName self.__dict[&#x27;CreateTime&#x27;] = int(time.time()) self.__dict[&#x27;MediaId&#x27;] = mediaId def send(self): XmlForm = &quot;&quot;&quot; &lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[&#123;ToUserName&#125;]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[&#123;FromUserName&#125;]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;&#123;CreateTime&#125;&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[image]]&gt;&lt;/MsgType&gt; &lt;Image&gt; &lt;MediaId&gt;&lt;![CDATA[&#123;MediaId&#125;]]&gt;&lt;/MediaId&gt; &lt;/Image&gt; &lt;/xml&gt; &quot;&quot;&quot; return XmlForm.format(**self.__dict) 设置JS接口安全域名","tags":["公众号开发"],"categories":["开发"]},{"title":"校招一览","path":"/2024/06/09/校园招聘/","content":"#腾讯 腾讯：Tencent 腾讯 只能投一个岗位 岗位投递 | 腾讯校招 (qq.com) 工作地：成都 实习生岗位投递 | 腾讯校招 (qq.com) 软件开发-后台开发方向 登录方式：微信 简历页：我的简历 | 腾讯校招 (qq.com) 应聘进度：应聘进度 | 腾讯校招 (qq.com) #小米 小米：校园招聘 (xiaomi.com) 实习生招聘：小米实习生招聘 (mioffice.cn) 在成都没有相关招聘 #阿里 阿里系列：阿里巴巴集团招聘官网 (alibaba.com) ​\t总公司阿里巴巴：阿里巴巴控股集团招聘官网 (alibaba.com) IT服务工程师：IT服务工程师 (alibaba.com) ​\t阿里云：阿里云校园招聘 (aliyun.com) 项目制实习生不用看 可以投两个岗位 研发工程师C&#x2F;C++ 毕业时间不满足无法投递 ​\t淘宝：淘天集团招聘官网 (taotian.com) 实习生：淘天集团校园招聘 (taotian.com) 没成都 ​\t饿了么：饿了么招聘官网 (ele.me) 没成都 ​\t高德：高德地图招聘官网 (amap.com) 没成都 ​\t阿里国际：阿里国际数字商业集团招聘官网 (alibaba.com) 没成都 ​\t菜鸟：【菜鸟招聘官网】菜鸟招聘_菜鸟校招_cainiao recruitment 没成都 ​\t阿里文娱：大文娱集团招聘官网 (alibaba-dme.com) 没成都 还有其他类别都没成都估计，看总网。 达摩院 银泰商业 ​ 网易网易校园招聘 (163.com) 实习生：职位 | 网易社会招聘 (163.com) HR 音乐人运营 IT运维 百度百度招聘 (baidu.com) 实习生-成都：百度校园招聘 (baidu.com) 可后续关注 智能客服研发组_JAVA工程实习生(J71934) 简历：百度校园招聘 (baidu.com) 字节字节跳动 (bytedance.com) 成都-实习-研发https://jobs.bytedance.com/campus/position?keywords=&amp;category=&amp;location=CT_22&amp;project=&amp;type=3&amp;job_hot_flag=&amp;current=1&amp;limit=10&amp;functionCategory=&amp;tag= 后端开发实习生-抖音 登录：191 应聘记录：https://jobs.bytedance.com/campus/position/application 滴滴滴滴招聘 (didiglobal.com) 成都-实习生滴滴 -实习生招聘 (mokahr.com) 后续关注 京东京东招聘-首页 (jd.com) 京东校招 (jd.com) 京东app扫码 投递进度：京东校招 (jd.com) 美团校园招聘 | 美团招聘 (meituan.com) 实习-成都职位列表 | 美团招聘 (meituan.com) 微信扫码+191 进度：个人中心 | 美团招聘 (meituan.com) oppoOPPO招聘 - 加入我们 join us 成都-OPPO招聘 - 加入我们 join us 知乎知乎校园招聘 - 智者四海（北京）技术有限公司 (mokahr.com)","tags":["校招"],"categories":["就业"]},{"title":"概率统计期末快速复习","path":"/2024/06/09/概率统计/","content":"#事件的运算及概率 ##事件及运算 P(AB)&#x3D;0 -&gt; P(ABC)&#x3D;0 ##古典概型 ##几何概型 全概率公式，贝叶斯公式条件概率，乘法公式 ##全概率，贝叶斯公式 一维随机变量离散型随机变量分布律，分布函数 函数的分布 连续型随机变量###概率密度，分布函数 函数的分布 五种重要分布离散型二项分布 泊松分布 连续型均匀分布 指数分布 ###正态分布 二维离散型随机变量 连续型二维随机变量 连续型二维随机变量函数的分布X+Y的分布 这里y简单，替换y Z&#x3D;XY Z&#x3D;max{X,Y} 数学期望，方差，协方差一维-期望与方程###离散型 连续型 二维离散型 连续型 ##协方差 ##切比雪夫不等式 大数定理及中心极限定理独立，同分布中心极限定理 二项分布中心极限定理 抽样分布常用统计量及性质 ##三种常见分布 参数估计距估计 最大似然估计 无偏估计 区间估计-置信区间假设检验 Z检验 t检验 ##$x^{2}$ 检验 两类分布","tags":["概率统计"],"categories":["大学课程"]},{"title":"oatpp-nginx","path":"/2024/03/27/oatpp+nginx/","content":"安装oatpp我先在oatpp的github的官方网站上找到windows的下载方式 官方网站：https://github.com/oatpp/oatpp 下载方式：https://oatpp.io/docs/installation/windows/ 而后我尝试进行下载，第一次我忽略了下方的cmake参数，下面我整理了完整指令，在想要安装oatpp的地方cmd输入指令 123456git clone https://github.com/oatpp/oatpp.gitcd oatppMD buildcd buildcmake -DCMAKE_BUILD_TYPE=Debug -DBUILD_SHARED_LIBS=OFF ..#更多参数可选项根据需求，我觉得这两个是必须的cmake --build . --target INSTALL 此处建议直接跳转到链接方法 既然库安好了，我开始想通过VS新建CMake项目链接库进行，但是我一直尝试都没有成功，文档放在这个最后(直接忽略) 目录结构为外层lib-oatpp test[代码存放] CMakelists.txt lib-oatpp中还有cmakelists test中有src-include-cmakelists 而后我又想直接把oatpp的源码放进项目中但是一直提示无法打开文件&#x2F;或找不到文件 历尽千辛万苦我终于知道如何链接了 ##链接方法 找到之前下载的oatpp&#x2F;src的位置”D:\\oatpp\\src”填入 右键项目-属性-c&#x2F;c++-附加包含目录 找到D:\\oatpp\\build\\src\\Debug 填入下图，里面有四个库文件 填入四个库 oatpp-test.lib oatpp.lib wsock32.lib ws2_32.lib 然后完事 ##CMakelistst(忽略) 以后也许我会再次尝试 顶层cmake文件，执行全局配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950cmake_minimum_required (VERSION 3.8)project (&quot;cmake-oatpp-nginx&quot;)set (CMAKE_CXX_STANDARD 17)set (CMAKE_CXX_STANDARD_REQUIRED ON) #严格遵循c++标准# 添加宏定义if (ZO_BT STREQUAL &quot;r&quot;)\tadd_definitions(-DOATPP_DISABLE_ENV_OBJECT_COUNTERS)\tmessage (STATUS &quot;Build type release&quot;)endif()if (UNIX)\tadd_definitions(-D_CRT_SECURE_NO_WARNINGS -D_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)\tadd_definitions(-DCPP_JWT_USE_VENDORED_NLOHMANN_JSON)\tadd_definitions(-DLINUX)\tadd_definitions(-DCHECK_TOKEN)\tadd_definitions(-DSTOP_PWD=&quot;01star&quot;)\tadd_definitions(-DOATPP_SWAGGER_SERVICE_NAME=&quot;$&#123;PROJECT_NAME&#125; for linux&quot;)\tadd_definitions(-DOATPP_SWAGGER_RES_PATH=&quot;res&quot;)\tadd_definitions(-DBSONCXX_STATIC -DMONGOCXX_STATIC -DENABLE_AUTOMATIC_INIT_AND_CLEANUP=OFF)else()\tadd_definitions(-DOATPP_SWAGGER_SERVICE_NAME=&quot;$&#123;PROJECT_NAME&#125; for windows&quot;)\tadd_definitions(-DOATPP_SWAGGER_RES_PATH=&quot;res&quot;)endif()# 在camke .. 的时候会输出提示目录路径message (STATUS &quot;Prefix dir is $&#123;CMAKE_INSTALL_PREFIX&#125;&quot;) #安装message (STATUS &quot;Binary dir is $&#123;PROJECT_BINARY_DIR&#125;&quot;) #二进制message (STATUS &quot;Source dir is $&#123;PROJECT_SOURCE_DIR&#125;&quot;) #源代码message (STATUS &quot;Build type is $&#123;CMAKE_BUILD_TYPE&#125;&quot;) #构建类型message (STATUS &quot;Platform for x64 = $&#123;CMAKE_CL_64&#125;&quot;) #平台# 定义一个预编译标头宏MACRO(ADD_MSVC_PRECOMPILED_HEADER PrecompiledHeader PrecompiledSource SourcesVar) IF(MSVC) GET_FILENAME_COMPONENT(PrecompiledBasename $&#123;PrecompiledHeader&#125; NAME_WE) SET(PrecompiledBinary &quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/$&#123;PrecompiledBasename&#125;.pch&quot;) SET(Sources $&#123;$&#123;SourcesVar&#125;&#125;) SET_SOURCE_FILES_PROPERTIES($&#123;PrecompiledSource&#125; PROPERTIES COMPILE_FLAGS &quot;/Yc\\&quot;$&#123;PrecompiledHeader&#125;\\&quot; /Fp\\&quot;$&#123;PrecompiledBinary&#125;\\&quot;&quot; OBJECT_OUTPUTS &quot;$&#123;PrecompiledBinary&#125;&quot;) SET_SOURCE_FILES_PROPERTIES($&#123;Sources&#125; PROPERTIES COMPILE_FLAGS &quot;/Yu\\&quot;$&#123;PrecompiledHeader&#125;\\&quot; /FI\\&quot;$&#123;PrecompiledHeader&#125;\\&quot; /Fp\\&quot;$&#123;PrecompiledBinary&#125;\\&quot;&quot; OBJECT_DEPENDS &quot;$&#123;PrecompiledBinary&#125;&quot;) LIST(APPEND $&#123;SourcesVar&#125; $&#123;PrecompiledSource&#125;) ENDIF(MSVC)ENDMACRO(ADD_MSVC_PRECOMPILED_HEADER)add_subdirectory (&quot;lib-oatpp&quot;)add_subdirectory (&quot;test&quot;) test目录下cmakelists 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465cmake_minimum_required (VERSION 3.8)set (appName test)include_directories (&quot;./&quot;)include_directories (&quot;../lib-oatpp/include&quot;)# 链接库路径，程序运行的时候也在这里找link_directories ($&#123;PROJECT_BINARY_DIR&#125;/lib-oatpp)#链接库的搜索路径if(UNIX)\tlink_directories ($&#123;PROJECT_SOURCE_DIR&#125;/lib-oatpp/lib64)# 如果是Windows环境elseif(WIN32)\tif (CMAKE_CL_64) link_directories ($&#123;PROJECT_SOURCE_DIR&#125;/lib-oatpp/lib64/openssl) if(ZO_BT STREQUAL &quot;r&quot;) link_directories ($&#123;PROJECT_SOURCE_DIR&#125;/lib-oatpp/lib64) else() link_directories ($&#123;PROJECT_SOURCE_DIR&#125;/lib-oatpp/lib64/debug) endif()\telse() link_directories ($&#123;PROJECT_SOURCE_DIR&#125;/lib-oatpp/lib/openssl) if(ZO_BT STREQUAL &quot;r&quot;) link_directories ($&#123;PROJECT_SOURCE_DIR&#125;/lib-oatpp/lib) else() link_directories ($&#123;PROJECT_SOURCE_DIR&#125;/lib-oatpp/lib/debug) endif()\tendif()endif()# 获取要编译的源代码file (GLOB_RECURSE SC_FILES ./*.cpp) #通配符-当前目录以及子目录下所有的.cpp文件list (REMOVE_ITEM SC_FILES &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/./stdafx.cpp&quot;) #从列表SC_FILES中移除指定文件-预编译头文件# 设置预编译标头if(WIN32)\tADD_MSVC_PRECOMPILED_HEADER(&quot;stdafx.h&quot; &quot;stdafx.cpp&quot; SC_FILES)endif()# 编译可执行文件add_executable ($&#123;appName&#125; $&#123;SC_FILES&#125;)# 链接库target_link_libraries ($&#123;appName&#125; &quot;lib-oatpp&quot;)# Window平台复制dll文件到可执行文件目录if(WIN32)\tfile (GLOB_RECURSE dycopy $&#123;ZO_DY_DIR&#125;/*.dll)\tfile (COPY $&#123;dycopy&#125; DESTINATION &quot;$&#123;PROJECT_BINARY_DIR&#125;/$&#123;appName&#125;&quot;)endif()# Window平台复制项目配置到可执行文件目录if(WIN32)\tfile (GLOB conf &quot;conf/*&quot;)\tfile (COPY $&#123;conf&#125; DESTINATION $&#123;PROJECT_BINARY_DIR&#125;/$&#123;appName&#125;/conf)endif()# 安装文件# public目录if(IS_ARCH_DEMO)\tinstall (DIRECTORY &quot;public&quot; DESTINATION $&#123;appName&#125;)endif()# 可执行文件install (TARGETS $&#123;appName&#125; RUNTIME DESTINATION $&#123;appName&#125;)# Window平台复制项目配置到可执行文件目录if(WIN32)\tinstall (DIRECTORY &quot;conf&quot; DESTINATION $&#123;appName&#125;)endif() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// main.cpp#include &quot;oatpp/web/server/HttpConnectionHandler.hpp&quot;#include &quot;oatpp/web/server/HttpRouter.hpp&quot;#include &quot;oatpp/web/server/HttpRequestHandler.hpp&quot;#include &quot;oatpp/web/protocol/http/outgoing/ResponseFactory.hpp&quot;#include &quot;oatpp/network/tcp/server/ConnectionProvider.hpp&quot;#include &quot;oatpp/core/macro/component.hpp&quot;class MyController : public oatpp::web::server::HttpRequestHandler &#123;public: /** * Handle incoming HTTP request */ std::shared_ptr&lt;OutgoingResponse&gt; handle(const std::shared_ptr&lt;IncomingRequest&gt;&amp; /*request*/) override &#123; // Return &quot;Hello, World!&quot; response return oatpp::web::protocol::http::outgoing::ResponseFactory::createResponse(Status::CODE_200, &quot;Hello, World!&quot;); &#125;&#125;;/** * Example ConnectionProvider component that listens on port 8080 */OATPP_CREATE_COMPONENT(std::shared_ptr&lt;oatpp::network::ServerConnectionProvider&gt;, serverConnectionProvider)([] &#123; return oatpp::network::tcp::server::ConnectionProvider::createShared(&#123; &quot;0.0.0.0&quot;, 8080, oatpp::network::Address::IP_4 &#125;);&#125;());/** * Example Router component */OATPP_CREATE_COMPONENT(std::shared_ptr&lt;oatpp::web::server::HttpRouter&gt;, httpRouter)([] &#123; auto router = oatpp::web::server::HttpRouter::createShared(); router-&gt;route(&quot;GET&quot;, &quot;/api/hello&quot;, std::make_shared&lt;MyController&gt;()); return router;&#125;());/** * Example ConnectionHandler component that combines ConnectionProvider and Router */OATPP_CREATE_COMPONENT(std::shared_ptr&lt;oatpp::network::ConnectionHandler&gt;, serverConnectionHandler)([] &#123; OATPP_COMPONENT(std::shared_ptr&lt;oatpp::network::ServerConnectionProvider&gt;, connectionProvider); // get ConnectionProvider component OATPP_COMPONENT(std::shared_ptr&lt;oatpp::web::server::HttpRouter&gt;, router); // get Router component auto connectionHandler = oatpp::web::server::HttpConnectionHandler::createShared(router); connectionHandler-&gt;setConnectionProvider(connectionProvider); return connectionHandler;&#125;());int main() &#123; OATPP_COMPONENT(std::shared_ptr&lt;oatpp::network::ServerConnectionProvider&gt;, connectionProvider); OATPP_COMPONENT(std::shared_ptr&lt;oatpp::network::ConnectionHandler&gt;, connectionHandler); oatpp::network::Server server(connectionProvider, connectionHandler); // Print info about server port OATPP_LOGI(&quot;MyApp&quot;, &quot;Server running on port %s&quot;, connectionProvider-&gt;getProperty(&quot;port&quot;).toString()-&gt;c_str()); // Run server server.run(); return 0;&#125; 在这个示例中，我们创建了一个名为 MyController 的类，用于处理 HTTP 请求，并返回 “Hello, World!” 消息。然后，我们定义了一个 HTTP 路由，将 /api/hello 路径映射到 MyController 类。最后，我们创建了一个 HTTP 服务器，监听在 8080 端口上，并将路由和连接提供器与之关联。 编译并运行这个程序，它将启动一个 HTTP 服务器，监听在 8080 端口上。接下来，你需要配置 Nginx，将 /api/hello 请求代理到这个端口上。在 Nginx 的配置文件中，你可以添加类似以下的配置： 12345678nginxCopy codeserver &#123; listen 80; server_name your_server_domain.com; location /api/hello &#123; proxy_pass http://127.0.0.1:8080; &#125;&#125; 保存并重新加载 Nginx 配置，然后访问 http://your_server_domain.com/api/hello，你应该能够看到 “Hello, World!” 的响应。 Step by Step1234567891011121314151617181920212223242526272829303132333435#include &quot;oatpp/web/server/HttpConnectionHandler.hpp&quot;#include &quot;oatpp/network/Server.hpp&quot;#include &quot;oatpp/network/tcp/server/ConnectionProvider.hpp&quot;void run() &#123;\t/* Create Router for HTTP requests routing */\tauto router = oatpp::web::server::HttpRouter::createShared();//Http请求的路由，url映射到端点处理程序，现在没有声明端点，返回404\t/* Create HTTP connection handler with router *///http连接处理，每一个连接一个线程\tauto connectionHandler = oatpp::web::server::HttpConnectionHandler::createShared(router);\t/* Create TCP connection provider *///tcp连接，绑定一个端口\tauto connectionProvider = oatpp::network::tcp::server::ConnectionProvider::createShared(&#123; &quot;localhost&quot;, 8000, oatpp::network::Address::IP_4 &#125;);\t/* Create server which takes provided TCP connections and passes them to HTTP connection handler */\toatpp::network::Server server(connectionProvider, connectionHandler);//server运行一个循环，获取tcp连接，传到连接处理\t/* Print info about server port */\tOATPP_LOGI(&quot;MyApp&quot;, &quot;Server running on port %s&quot;, connectionProvider-&gt;getProperty(&quot;port&quot;).getData());\t/* Run server */\tserver.run();&#125;int main() &#123;\t/* Init oatpp Environment */\toatpp::base::Environment::init();\t/* Run App */\trun();\t/* Destroy oatpp Environment */\toatpp::base::Environment::destroy();\treturn 0;&#125; ###添加请求处理程序 当url &#x2F;hello请求做出处理 访问http:&#x2F;localhost:8000&#x2F;hello 返回hello world消息 12345678910class Handler : public oatpp::web::server::HttpRequestHandler &#123;public: std::shared_ptr&lt;OutgoingResponse&gt; handle(const std::shared_ptr&lt;IncomingRequest&gt;&amp; request) override &#123; return ResponseFactory::createResponse(Status::CODE_200, &quot;Hello World!&quot;); &#125;&#125;;void run()&#123;\trouter-&gt;route(&quot;GET&quot;, &quot;/hello&quot;, std::make_shared&lt;Handler&gt;());&#125; 使用JSON对象进行响应为了序列化&#x2F;反序列化对象，oatpp 使用特殊的[数据传输对象(DTO)和ObjectMappers 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;oatpp/parser/json/mapping/ObjectMapper.hpp&quot;#include &quot;oatpp/core/macro/codegen.hpp&quot;/* Begin DTO code-generation */#include OATPP_CODEGEN_BEGIN(DTO)/** * Message Data-Transfer-Object */class MessageDto : public oatpp::DTO &#123; DTO_INIT(MessageDto, DTO /* Extends */) DTO_FIELD(Int32, statusCode); // Status code field DTO_FIELD(String, message); // Message field&#125;;/* End DTO code-generation */#include OATPP_CODEGEN_END(DTO)class Handler : public oatpp::web::server::HttpRequestHandler &#123;private: std::shared_ptr&lt;oatpp::data::mapping::ObjectMapper&gt; m_objectMapper;public: /** * Constructor with object mapper. * @param objectMapper - object mapper used to serialize objects. */ Handler(const std::shared_ptr&lt;oatpp::data::mapping::ObjectMapper&gt;&amp; objectMapper) : m_objectMapper(objectMapper) &#123;&#125; /** * Handle incoming request and return outgoing response. */ std::shared_ptr&lt;OutgoingResponse&gt; handle(const std::shared_ptr&lt;IncomingRequest&gt;&amp; request) override &#123; auto message = MessageDto::createShared(); message-&gt;statusCode = 1024; message-&gt;message = &quot;Hello DTO!&quot;; return ResponseFactory::createResponse(Status::CODE_200, message, m_objectMapper); &#125;&#125;;void run() &#123; /* Create json object mapper */ auto objectMapper = oatpp::parser::json::mapping::ObjectMapper::createShared(); /* Create Router for HTTP requests routing */ auto router = oatpp::web::server::HttpRouter::createShared(); /* Route GET - &quot;/hello&quot; requests to Handler */ router-&gt;route(&quot;GET&quot;, &quot;/hello&quot;, std::make_shared&lt;Handler&gt;(objectMapper /* json object mapper */ )); &#125; oatpp的结构DTO 数据传输对象 定义了数据的格式 controller 使用api controller 端点处理程序(处理路由请求) 使用dto中的类封装消息 AppComponent.hpp 定义必须的组件(HTTP连接，请求路由，TCP连接，ObjectMapper) App.cpp main 路由器(请求) 获取上述组件中的路由-获取controller中的处理程序-建立路由到处理程序的映射 ​ 获取HTTP连接-获取TCP连接-建立服务-从TCP连接提供者发送消息到http连接处理 代码DTOs.hpp 123456789101112131415161718192021222324252627282930313233#ifndef DTOs_hpp#define DTOs_hpp#include &quot;oatpp/core/data/mapping/type/Object.hpp&quot;#include &quot;oatpp/core/macro/codegen.hpp&quot;#include &quot;oatpp/parser/json/mapping/ObjectMapper.hpp&quot;#include &quot;oatpp/web/server/HttpConnectionHandler.hpp&quot;#include &quot;oatpp/network/Server.hpp&quot;#include &quot;oatpp/network/tcp/server/ConnectionProvider.hpp&quot;/* Begin DTO code-generation */#include OATPP_CODEGEN_BEGIN(DTO)/** * Message Data-Transfer-Object */class MessageDto : public oatpp::DTO &#123;\tDTO_INIT(MessageDto, DTO /* Extends */) DTO_FIELD(Int32, statusCode); // Status code field\tDTO_FIELD(String, message); // Message field&#125;;/* TODO - Add more DTOs here *//* End DTO code-generation */#include OATPP_CODEGEN_END(DTO)#endif /* DTOs_hpp */ MyController.hpp 123456789101112131415161718192021222324252627282930313233343536373839#ifndef MyController_hpp#define MyController_hpp#include &quot;dto/DTOs.hpp&quot;#include &quot;oatpp/web/server/api/ApiController.hpp&quot;#include &quot;oatpp/core/macro/codegen.hpp&quot;#include &quot;oatpp/core/macro/component.hpp&quot;#include OATPP_CODEGEN_BEGIN(ApiController) ///&lt; Begin Codegen/** * Sample Api Controller. */class MyController : public oatpp::web::server::api::ApiController &#123;public: /** * Constructor with object mapper. * @param objectMapper - default object mapper used to serialize/deserialize DTOs. */ MyController(OATPP_COMPONENT(std::shared_ptr&lt;ObjectMapper&gt;, objectMapper)) : oatpp::web::server::api::ApiController(objectMapper) &#123;&#125;public: ENDPOINT(&quot;GET&quot;, &quot;/hello&quot;, root) &#123; auto dto = MessageDto::createShared(); dto-&gt;statusCode = 200; dto-&gt;message = &quot;Hello World!&quot;; return createDtoResponse(Status::CODE_200, dto); &#125; // TODO Insert Your endpoints here !!!&#125;;#include OATPP_CODEGEN_END(ApiController) ///&lt; End Codegen#endif /* MyController_hpp */ AppComponent.hpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#ifndef AppComponent_hpp#define AppComponent_hpp#include &quot;oatpp/parser/json/mapping/ObjectMapper.hpp&quot;#include &quot;oatpp/web/server/HttpConnectionHandler.hpp&quot;#include &quot;oatpp/network/tcp/server/ConnectionProvider.hpp&quot;#include &quot;oatpp/core/macro/component.hpp&quot;/** * Class which creates and holds Application components and registers components in oatpp::base::Environment * Order of components initialization is from top to bottom */class AppComponent &#123;public: /** * Create ConnectionProvider component which listens on the port */ OATPP_CREATE_COMPONENT(std::shared_ptr&lt;oatpp::network::ServerConnectionProvider&gt;, serverConnectionProvider)([] &#123; return oatpp::network::tcp::server::ConnectionProvider::createShared(&#123; &quot;localhost&quot;, 8000, oatpp::network::Address::IP_4 &#125;); &#125;()); /** * Create Router component */ OATPP_CREATE_COMPONENT(std::shared_ptr&lt;oatpp::web::server::HttpRouter&gt;, httpRouter)([] &#123; return oatpp::web::server::HttpRouter::createShared(); &#125;()); /** * Create ConnectionHandler component which uses Router component to route requests */ OATPP_CREATE_COMPONENT(std::shared_ptr&lt;oatpp::network::ConnectionHandler&gt;, serverConnectionHandler)([] &#123; OATPP_COMPONENT(std::shared_ptr&lt;oatpp::web::server::HttpRouter&gt;, router); // get Router component return oatpp::web::server::HttpConnectionHandler::createShared(router); &#125;()); /** * Create ObjectMapper component to serialize/deserialize DTOs in Contoller&#x27;s API */ OATPP_CREATE_COMPONENT(std::shared_ptr&lt;oatpp::data::mapping::ObjectMapper&gt;, apiObjectMapper)([] &#123; return oatpp::parser::json::mapping::ObjectMapper::createShared(); &#125;());&#125;;#endif /* AppComponent_hpp */ App.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &quot;controller/MyController.hpp&quot;#include &quot;AppComponent.hpp&quot;#include &quot;oatpp/network/Server.hpp&quot;void run() &#123;\t/* Register Components in scope of run() method */\tAppComponent components;\t/* Get router component */\tOATPP_COMPONENT(std::shared_ptr&lt;oatpp::web::server::HttpRouter&gt;, router);\t/* Create MyController and add all of its endpoints to router */\tauto myController = std::make_shared&lt;MyController&gt;();\trouter-&gt;addController(myController);\t/* Get connection handler component */\tOATPP_COMPONENT(std::shared_ptr&lt;oatpp::network::ConnectionHandler&gt;, connectionHandler);\t/* Get connection provider component */\tOATPP_COMPONENT(std::shared_ptr&lt;oatpp::network::ServerConnectionProvider&gt;, connectionProvider);\t/* Create server which takes provided TCP connections and passes them to HTTP connection handler */\toatpp::network::Server server(connectionProvider, connectionHandler);\t/* Priny info about server port */\tOATPP_LOGI(&quot;MyApp&quot;, &quot;Server running on port %s&quot;, connectionProvider-&gt;getProperty(&quot;port&quot;).getData());\t/* Run server */\tserver.run();&#125;int main(int argc, const char* argv[]) &#123;\t/* Init oatpp Environment */\toatpp::base::Environment::init();\t/* Run App */\trun();\t/* Destroy oatpp Environment */\toatpp::base::Environment::destroy();\treturn 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#ifndef MyController_hpp#define MyController_hpp#include &quot;dto/DTOs.hpp&quot;#include &quot;oatpp/web/server/api/ApiController.hpp&quot;#include &quot;oatpp/core/macro/codegen.hpp&quot;#include &quot;oatpp/core/macro/component.hpp&quot;#include OATPP_CODEGEN_BEGIN(ApiController) ///&lt; Begin Codegen/** * Sample Api Controller. */class MyController : public oatpp::web::server::api::ApiController &#123;public: /** * Constructor with object mapper. * @param objectMapper - default object mapper used to serialize/deserialize DTOs. */ MyController(OATPP_COMPONENT(std::shared_ptr&lt;oatpp::data::mapping::ObjectMapper&gt;, objectMapper)) : oatpp::web::server::api::ApiController(objectMapper) &#123;&#125;public: ENDPOINT(&quot;GET&quot;, &quot;/hello&quot;, roothello) &#123; auto dto = MessageDto::createShared(); dto-&gt;statusCode = 200; dto-&gt;message = &quot;Hello World!&quot;; return createDtoResponse(Status::CODE_200, dto); &#125; // TODO Insert Your endpoints here !!! ENDPOINT(&quot;GET&quot;, &quot;/&quot;, root) &#123; auto response = createResponse(Status::CODE_200, &quot;&lt;html&gt;&lt;body&gt;&lt;form action=\\&quot;/submit\\&quot; method=\\&quot;post\\&quot;&gt;&lt;input type=\\&quot;text\\&quot; name=\\&quot;input\\&quot; placeholder=\\&quot;Enter something\\&quot;&gt;&lt;button type=\\&quot;submit\\&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&quot;); response-&gt;putHeader(oatpp::web::protocol::http::Header::CONTENT_TYPE, &quot;text/html&quot;); return response; &#125; ENDPOINT(&quot;POST&quot;, &quot;/submit&quot;, submit, BODY_STRING(String, body)) &#123; OATPP_LOGI(&quot;MyController&quot;, &quot;Received input: %s&quot;, body-&gt;c_str()); auto response = createResponse(Status::CODE_200, &quot;Received input: &quot; + *body); response-&gt;putHeader(oatpp::web::protocol::http::Header::CONTENT_TYPE, &quot;text/plain&quot;); return response; &#125;&#125;;#include OATPP_CODEGEN_END(ApiController) ///&lt; End Codegen#endif /* MyController_hpp */","tags":["HTTP 请求处理、路由、JSON 序列化","Web开发框架"],"categories":["Web"]},{"title":"Nginx","path":"/2024/03/25/Nginx/","content":"安装最流行的web服务器软件 安装 yum install nginx 启动 nginx 关闭 nginx -s stop 查看80号端口占用情况 lsof -i:80 阿里云上打开这个端口，关闭防火墙，访问ip 关闭linux防火墙 root下 cd &#x2F;bin systemctl stop firewalld.service 关闭防火墙自启 systemctl stop firewalld.service 然后重启虚拟机 常用指令12345678nginx # 启动Nginxnginx -c filename # 指定配置⽂件nginx -V # 查看Nginx的版本和编译参数等信息nginx -t # 检查配置⽂件是否正确，也可⽤来定位配置⽂件的位置nginx -s quit # 优雅停⽌Nginxnginx -s stop # 快速停⽌Nginxnginx -s reload # 重新加载配置⽂件nginx -s reopen # 重新打开⽇志⽂件 Hexo静态站点部署查看安装目录 nginx -V –prefix&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx 配置文件nginx.conf位置 –conf-path&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf ​ 或nginx -t ​ &#x2F;etc&#x2F;nginx&#x2F;nginx.conf 直接在vscode上打开或者ctrl+左键 默认网页是 安装位置&#x2F;usr&#x2F;share&#x2F;nginx 中html文件夹里的index.html 用Hexo生成一个简单的静态博客网站-然后部署在nginx里面 可以把markdown格式文档转化成静态界面 ##安装Nodejs 安装git 建议直接看后面安装最新版 yum install nodejs npm install hexo-cli -g cd mkdir nginx cd nginx hexo init blog cd blog hexo g 生成一个静态站点，把markdown文件转化为静态页面放到public文件夹下 hexo s 启动本地服务器 如果失败node版本不够 安装新版Nodejsnode --version 版本过低 使用官方提供的方法安装安装nvm curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash 或wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash 重新启动终端或者执行 source ~/.bashrc 或 source ~/.bash_profile 来使 nvm 生效 nvm install node nvm alias default node node –version 浏览器上输入localhost:4000展示网页 把public目录下的所有内容复制到html目录下 ​\tcd public ​\tcp -rf * &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 或者hexo d一键完成部署 配置文件worker进程的数量可以根据配置文件修改 worker_processes 1 文件中修改数量 nginx -t 检查配置文件是否正确 修改之后需要重新加载 nginx -s reload ps -ef |grep nginx可以看进程的数量 设置成和服务器内核数量相同比较合适设置成auto自动设置 events 服务器与客户端之间的配置 worker_connections 1024代表同时接受多少个网络连接 IO模型等 http 虚拟主机，反向代理，负载均衡都在这里配置 ​\t其中server块是虚拟主机 最后一行include servers&#x2F; 把servers目录下所有文件都包含进来* 这样就可以把每个虚拟主机的配置放到一个单独的文件里面 这一部分可以看pdf 反向代理和负载均衡反向代理代理的是服务端，正向代理：vpn代理客户端去访问服务端 反向：访问谷歌，谷歌用域名代理其他服务器 main.go 使用Golang生成一段web服务代码，在8000端口监听 go run main.go 在浏览器中访问这个ip的8000号端口就可以看到 再复制两份，监听8001 8002 ctrl+shift+’启动新终端 启动这两个，分别访问就可以看到 code code &#x2F;etc&#x2F;nginx&#x2F;nginx.conf 在server块上方添加反向代理配置 12345upstream backend&#123;\tserver 47.115.215.143:8000;\tserver 47.115.215.143:8001;\tserver 47.115.215.143:8002;&#125; 在server中添加location配置 123location&#123;\tproxy_pass http://backend; #与上方反向代理一致&#125; nginx -s reload 访问47.115.215.143&#x2F;app 默认轮询访问，可以设置权重也就是访问到的概率，修改配置 123456upstream backend&#123;\tip_hash; #根据客户端的ip地址进行哈希，同一个客户端的请求会分配到同一个服务器\tserver 47.115.215.143:8000 weight=3;\tserver 47.115.215.143:8001;\tserver 47.115.215.143:8002;&#125; HTTPShttp 80 https 443 需要使用ssl证书(免费申请)-得到密钥文件+证书文件 也可以申请自签 生成两个文件.key .pem server中添加以下内容 nginx -s reload https://47.115.215.143 这种没有ca机构验证会有安全提示 自动跳到https 虚拟主机一个server就是一个虚拟主机，可以在servers文件夹里新建一个文件，把配置文件复制进去也没有问题 会自动根据访问的域名匹配server项 部署一个Vue(渐进式JavaScript前端框架) …此处省略配置过程 在servers目录下新建vue.conf root跟打包好的vue目录","tags":["反向代理"],"categories":["Web"]},{"title":"git","path":"/2024/03/25/git/","content":"在想要存放项目文件夹的地方git bash here 克隆远程仓库 git clone https...... 右键-在vscode中打开 在本地修改完文件后从vscode或其他工具上传 输入信息并提交-同步更改 从远程拉取并且删除本地多余的文件 git pull --prune","tags":["代码托管"],"categories":["工具"]},{"title":"hexo","path":"/2024/03/25/hexo/","content":"hexo搭建github博客网页安装请看Nginx基础篇 新建仓库-仓库名字：用户名.github.io,勾选readme 这时在网站上可以直接访问到 cd在之前的nginx&#x2F;bolg文件夹中或者自己创建一个文件夹 hexo new &quot;tutu&#39;s personal blog&quot; 12345[root@iZf8zeh9f5g1mo4rk51t4pZ blog]# hexo new &quot;tutu&#x27;s personal blog&quot;INFO Validating configINFO Created: ~/nginx/blog/source/_posts/tutu-s-personal-blog.mdhexo generate #生成静态网页文件hexo deploy #部署 编辑_config.yml 1234deploy: type: git repo: git@github.com:你的用户名/你的用户名.github.io.git branch: master 下载插件 npm install hexo-deployer-git –save git config –global user.email &#116;&#x75;&#x74;&#117;&#50;&#48;&#x36;&#49;&#56;&#54;&#x37;&#x39;&#48;&#x33;&#x40;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#111;&#109; git config –global user.name tutuLP 地址改用以下： &#103;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#x6d;:tutuLP&#x2F;tutuLP.github.io.git 可能需要打开端口22 9418 https://github.com/tutuLP/tutuLP.github.io.git hexo deploy 部署到github服务器平台 进入GitHub仓库的设置页面，找到GitHub Pages选项，并将源设置为master branch。 再次访问即可成功 以上只是构建本地的文件生成静态网站上传到github服务器 现在我们pull仓库中的文件进行构建 cd source&#x2F;_posts git init 我这里生成的分治是master比较古老 git remote add origin https://github.com/tutuLP/tutuLP.github.io.git 建立关联 git branch –set-upstream-to&#x3D;origin&#x2F;main master 本地master分支与远程main关联 git pull origin main –allow-unrelated-histories 拉取-运行历史不同步 然后回到blog hexo generate hexo deploy pull进来的文件不会自动拿文件名作为标题，我们需要在文档前面加上一段Front Matter，用于指定文章元数据的YAML格式的内容 12345678910---title: &quot;文章标题&quot;date: YYYY-MM-DD HH:MM:SScategories: - 分类1 - 分类2tags: - 标签1 - 标签2--- 主题stellar来源：Stellar：开始您全新的博客之旅 - XAOXUU 还可在上方网页上搜索Volantis另一个主题 进入blog npm i hexo-theme-stellar 在 _config.yml 文件中找到并修改： theme: stellar 12345678title: 您的网站名称avatar: 您的头像链接favicon: 您的网站icon# subtitle: # subtitle 已移至主题配置中# 多语言language: - zh-CN - en _config.yml 文件旁边新建一个文件： _config.stellar.yml ，在这个文件中的配置信息优先级高于主题文件夹中的配置文件。 默认生成 Open Graph 标签，如果您不希望生成它，可以在主题配置文件中关闭： 123blog/_config.stellar.ymlopen_graph: enable: true twitter_id: # for open_graph meta 管理构建好的静态网页hexo generate后生成的资源存放在public文件夹中 当我测试时创建的分类和标签会永远存在，即使我删除.md文档重新构建也依旧存在 cd &#x2F;public&#x2F;categories rm -rf 然后清除临时文件 生成 推送 hexo clean hexo generate hexo deploy ##部署的时候提示需要输入账号密码 cd ~&#x2F;.ssh ssh-keygen -t rsa -b 2048 -C ‘github注册邮箱’ ssh-keygen -t rsa -b 2048 -C ‘&#116;&#x75;&#116;&#x75;&#x32;&#x30;&#54;&#49;&#x38;&#x36;&#55;&#57;&#x30;&#51;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;‘ 一路回车即可 粘贴.pub文件的内容到SSH keys 进入hexo项目根目录 cd blog 删除文件 .deploy_git 修改_config.yml repo:项目的SSH地址 自定义域名https://tutulp.github.io/ 是的，你可以通过将自定义域名（例如你拥有的域名）映射到你的GitHub Pages网站来实现这一目标。以下是一些步骤： 购买域名：首先，你需要购买一个域名，例如yourdomain.com。你可以通过注册商（例如GoDaddy、Namecheap等）购买域名。 配置DNS记录：登录到你的域名注册商的控制面板，并配置DNS记录，将你的域名指向GitHub Pages。通常，你需要添加一个CNAME记录，将域名指向你的GitHub Pages用户名，例如yourusername.github.io。具体的步骤可能会因注册商而异，你可以参考GitHub Pages提供的文档或向注册商寻求帮助。 在GitHub设置中配置自定义域名：登录到GitHub，进入你的仓库设置页面，将你的自定义域名添加到”Custom domain”字段中。 等待DNS生效：一旦你配置了DNS记录并保存了更改，你需要等待一段时间（通常几小时至48小时），直到DNS记录生效。一旦生效，你的域名就会指向你的GitHub Pages网站。 HTTPS支持：GitHub Pages支持HTTPS，但你需要确保你的域名有有效的SSL证书。你可以使用GitHub提供的自动生成的SSL证书，或者使用其他证书颁发机构提供的证书。 通过这些步骤，你就可以将你的GitHub Pages网站与你自己的域名关联起来，使访问者在浏览器中看到你的域名，但实际上打开的是GitHub Pages上托管的网站。","tags":["Node.js","静态网站生成器"],"categories":["Web"]},{"title":"vscode","path":"/2024/03/25/vscode/","content":"ssh远程连接错误报错： 无法建立连接，下载vscode服务器失败-请在远程安装curl 解决办法： 删除远程服务器家目录下的.vscode-server文件夹，linux的家目录路径是：&#x2F;home&#x2F;yourusername ctrl+shift+p 输入kill 输入密码后删除服务器中的服务文件 再次连接会重新下载解决问题 配置c语言环境下载下载MinGW https://sourceforge.net/projects/mingw-w64/ 安装到你找得到英文路径下 打开这个文件夹找到bin文件夹的位置 “D:\\MinGW\\bin” 配置环境变量 右键此电脑-属性-高级系统设置-环境变量-上方Path-编辑-新建-放入地址(不要””) 下载vscode VScode插件C&#x2F;C++ Chinese(可选)两个插件 工作区配置####建立工作区 先在喜欢的地方建一个文件夹，这个文件夹用来存放你的代码和工作区的地方 打开文件夹，在空白处右键通过vscode打开 文件-将工作区另存为-选择这个文件夹 配置.vscode文件可以不用下载老版本的c&#x2F;c++插件，只需要手动建立一下的一个文件夹和两个文件 手动输入文件名和后缀 下面我附上配置内容 我已经加上了注释，可以根据自己喜好配置 1234567891011121314151617181920212223242526272829303132333435//launch.json&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;gcc.exe - 生成和调试活动文件&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\\\a.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;D:\\\\MinGW\\\\bin&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, //在外部控制台中打开-输出内容将不会出现在下方 &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;D:\\\\MinGW\\\\bin\\\\gdb.exe&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125;, &#123; &quot;description&quot;: &quot;将反汇编风格设置为 Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;C/C++: gcc.exe 生成活动文件&quot; &#125; ]&#125; 123456789101112131415161718192021222324252627282930//tasks.json&#123; &quot;tasks&quot;: [ &#123; &quot;type&quot;: &quot;cppbuild&quot;, &quot;label&quot;: &quot;C/C++: gcc.exe 生成活动文件&quot;, &quot;command&quot;: &quot;D:\\\\MinGW\\\\bin\\\\gcc.exe&quot;, &quot;args&quot;: [ &quot;-fdiagnostics-color=always&quot;, &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;\\\\a.exe&quot;, &quot;-fexec-charset=GBK&quot; //解决中文乱码 ], &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;D:\\\\MinGW\\\\bin&quot; &#125;, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, &quot;detail&quot;: &quot;调试器生成的任务。&quot; &#125; ], &quot;version&quot;: &quot;2.0.0&quot;&#125; ####建立a.exe 在每一个有代码的同级目录下都要新建一个a.exe 每次运行代码都会覆盖写入可执行文件，避免出现一堆exe文件，我已经在上方两个文件中改动优化了 例如上方的目录结构，其中可以内涵很多文件夹，只需要每个文件夹都有一个a.exe 运行代码在代码的头文件中加上 #include&lt;stdlib.h&gt; main函数体末尾加上 system(“pause”); 运行-GDB-gcc 为了方便打开，我们找到vscode的安装目录，右键图标-发送到桌面 右键桌面的这个vscode图标-属性-在目标后面加上文件夹的位置 就可以双击打开了 或者直接双击我们之前保存的工作区也同样的效果","tags":["ssh","c"],"categories":["工具"]}]